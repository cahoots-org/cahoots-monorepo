"""Data Flow Validator for Event Models

Validates that all data has a proper source throughout the entire flow:
UI → Command → Event → Read Model → UI

This ensures the event model specification is complete and can be used
for code generation without ambiguity.
"""

from typing import List, Dict, Any, Tuple
from dataclasses import dataclass


@dataclass
class DataFlowIssue:
    """Represents a data flow validation issue"""
    severity: str  # 'error' or 'warning'
    category: str  # 'missing_source', 'orphaned_field', 'incomplete_flow', 'implicit_source'
    message: str
    details: Dict[str, Any]
    suggestions: List[str]


class DataFlowValidator:
    """Validates data flow completeness in event models with schemas"""

    def validate(self, event_model: Dict[str, Any]) -> Tuple[bool, List[DataFlowIssue]]:
        """
        Validate complete data flow through the event model.

        Returns:
            (is_valid, issues): Tuple of boolean and list of issues
        """
        issues = []

        # Extract components
        commands = event_model.get('commands', [])
        events = event_model.get('events', [])
        read_models = event_model.get('read_models', [])
        chapters = event_model.get('chapters', [])
        wireframes = event_model.get('wireframes', [])

        # Validation 1: Command parameter sources
        issues.extend(self._validate_command_sources(commands, read_models, wireframes))

        # Validation 2: Event payload provenance
        issues.extend(self._validate_event_provenance(events, commands))

        # Validation 3: Read model field hydration
        issues.extend(self._validate_read_model_sources(read_models, events))

        # Validation 4: UI display data availability
        issues.extend(self._validate_ui_data_sources(wireframes, read_models))

        # Validation 5: Complete flow integrity (UI → Command → Event → Read Model → UI)
        issues.extend(self._validate_complete_flows(commands, events, read_models, wireframes))

        # Determine if valid (no errors, only warnings allowed)
        errors = [issue for issue in issues if issue.severity == 'error']
        is_valid = len(errors) == 0

        return is_valid, issues

    def _validate_command_sources(self, commands: List[Dict], read_models: List[Dict], wireframes: List[Dict]) -> List[DataFlowIssue]:
        """Validate that every command parameter has a valid source"""
        issues = []

        for command in commands:
            command_name = command.get('name', 'Unknown')
            parameters = command.get('parameters', [])

            for param in parameters:
                param_name = param.get('name')
                source = param.get('source', {})
                source_type = source.get('type')

                if not source_type:
                    issues.append(DataFlowIssue(
                        severity='error',
                        category='missing_source',
                        message=f"Command '{command_name}' parameter '{param_name}' has no source defined",
                        details={
                            'command': command_name,
                            'parameter': param_name,
                            'parameter_type': param.get('type')
                        },
                        suggestions=[
                            "Add source with type: 'ui_input' (from a UI component)",
                            "Add source with type: 'url_parameter' (from route URL)",
                            "Add source with type: 'read_model' (from displayed read model field)",
                            "Add source with type: 'system' (generated by system, e.g., UUID)",
                            "Add source with type: 'session' (from authenticated user session)"
                        ]
                    ))
                elif source_type == 'ui_input':
                    # Check if wireframe exists with this input
                    if not self._has_ui_input_for_command(wireframes, command_name, param_name):
                        issues.append(DataFlowIssue(
                            severity='warning',
                            category='implicit_source',
                            message=f"Command '{command_name}' parameter '{param_name}' source is 'ui_input' but no wireframe component found",
                            details={
                                'command': command_name,
                                'parameter': param_name,
                                'source': source
                            },
                            suggestions=[
                                f"Add wireframe component (type: 'input', field: '{param_name}') that triggers '{command_name}'",
                                "Update source details to reference the wireframe component"
                            ]
                        ))
                elif source_type == 'read_model':
                    # Check if read model field exists
                    read_model_ref = source.get('from', '')
                    if not self._read_model_field_exists(read_models, read_model_ref):
                        issues.append(DataFlowIssue(
                            severity='error',
                            category='missing_source',
                            message=f"Command '{command_name}' parameter '{param_name}' references non-existent read model field '{read_model_ref}'",
                            details={
                                'command': command_name,
                                'parameter': param_name,
                                'read_model_ref': read_model_ref,
                                'available_read_models': [rm.get('name') for rm in read_models]
                            },
                            suggestions=[
                                f"Add field '{read_model_ref}' to the corresponding read model",
                                "Update source to reference an existing read model field",
                                "Change source type if data doesn't come from a read model"
                            ]
                        ))

        return issues

    def _validate_event_provenance(self, events: List[Dict], commands: List[Dict]) -> List[DataFlowIssue]:
        """Validate that every event payload field has a valid source"""
        issues = []

        # Build command parameter map for quick lookup
        command_params = {}
        for command in commands:
            command_name = command.get('name')
            params = {p.get('name'): p for p in command.get('parameters', [])}
            command_params[command_name] = params

        for event in events:
            # Handle both DomainEvent objects and dicts
            if hasattr(event, 'name'):
                event_name = event.name
                payload = []  # DomainEvent objects don't have payload in current implementation
            else:
                event_name = event.get('name', 'Unknown')
                payload = event.get('payload', [])

            # Find which commands trigger this event
            triggering_commands = [
                cmd for cmd in commands
                if event_name in cmd.get('triggers_events', [])
            ]

            for field in payload:
                field_name = field.get('name')
                source = field.get('source', {})
                source_type = source.get('type')
                source_from = source.get('from', '')

                if not source_type:
                    issues.append(DataFlowIssue(
                        severity='error',
                        category='missing_source',
                        message=f"Event '{event_name}' payload field '{field_name}' has no source defined",
                        details={
                            'event': event_name,
                            'field': field_name,
                            'field_type': field.get('type'),
                            'triggering_commands': [cmd.get('name') for cmd in triggering_commands]
                        },
                        suggestions=[
                            "Add source with type: 'command_parameter' (passed from triggering command)",
                            "Add source with type: 'derived' (calculated from command parameters)",
                            "Add source with type: 'system' (generated by system)",
                            "Add source with type: 'lookup' (retrieved from external data source)"
                        ]
                    ))
                elif source_type == 'command_parameter':
                    # Validate the referenced command parameter exists
                    parts = source_from.split('.')
                    if len(parts) == 2:
                        ref_command, ref_param = parts
                        if ref_command in command_params:
                            if ref_param not in command_params[ref_command]:
                                issues.append(DataFlowIssue(
                                    severity='error',
                                    category='missing_source',
                                    message=f"Event '{event_name}' field '{field_name}' references non-existent parameter '{ref_param}' in command '{ref_command}'",
                                    details={
                                        'event': event_name,
                                        'field': field_name,
                                        'referenced_command': ref_command,
                                        'referenced_parameter': ref_param,
                                        'available_parameters': list(command_params[ref_command].keys())
                                    },
                                    suggestions=[
                                        f"Add parameter '{ref_param}' to command '{ref_command}'",
                                        f"Update source to reference an existing parameter from command '{ref_command}'",
                                        "Change source type if data doesn't come from command parameter"
                                    ]
                                ))

        return issues

    def _validate_read_model_sources(self, read_models: List[Dict], events: List[Any]) -> List[DataFlowIssue]:
        """Validate that every read model field is populated by events"""
        issues = []

        # Build event payload map for quick lookup
        event_fields = {}
        for event in events:
            if hasattr(event, 'name'):
                event_name = event.name
                payload = []  # DomainEvent objects don't have payload yet
            else:
                event_name = event.get('name')
                payload = event.get('payload', [])

            event_fields[event_name] = {f.get('name'): f for f in payload}

        for read_model in read_models:
            rm_name = read_model.get('name', 'Unknown')
            fields = read_model.get('fields', [])

            for field in fields:
                field_name = field.get('name')
                source = field.get('source', {})
                source_type = source.get('type')
                source_events = source.get('events', [])

                if not source_type:
                    issues.append(DataFlowIssue(
                        severity='error',
                        category='missing_source',
                        message=f"Read model '{rm_name}' field '{field_name}' has no source defined",
                        details={
                            'read_model': rm_name,
                            'field': field_name,
                            'field_type': field.get('type')
                        },
                        suggestions=[
                            "Add source with type: 'event_field' (direct mapping from event payload)",
                            "Add source with type: 'aggregation' (calculated from multiple events)",
                            "Add source with type: 'derived' (calculated from other read model fields)"
                        ]
                    ))
                elif source_type in ['event_field', 'aggregation']:
                    # Validate that source events exist
                    if not source_events:
                        issues.append(DataFlowIssue(
                            severity='error',
                            category='missing_source',
                            message=f"Read model '{rm_name}' field '{field_name}' has no source events listed",
                            details={
                                'read_model': rm_name,
                                'field': field_name,
                                'source_type': source_type
                            },
                            suggestions=[
                                "Add 'events' array listing which events populate this field",
                                "Example: \"events\": [\"ItemAdded\", \"ItemRemoved\"]"
                            ]
                        ))
                    else:
                        # Check events exist
                        event_names = [e.name if hasattr(e, 'name') else e.get('name') for e in events]
                        for source_event in source_events:
                            if source_event not in event_names:
                                issues.append(DataFlowIssue(
                                    severity='error',
                                    category='missing_source',
                                    message=f"Read model '{rm_name}' field '{field_name}' references non-existent event '{source_event}'",
                                    details={
                                        'read_model': rm_name,
                                        'field': field_name,
                                        'missing_event': source_event,
                                        'available_events': event_names[:10]  # Show first 10
                                    },
                                    suggestions=[
                                        f"Add event '{source_event}' to the event model",
                                        "Update source events to reference existing events",
                                        "Remove this source event if it's not needed"
                                    ]
                                ))

        return issues

    def _validate_ui_data_sources(self, wireframes: List[Dict], read_models: List[Dict]) -> List[DataFlowIssue]:
        """Validate that UI display components reference existing read model fields"""
        issues = []

        # Build read model field map
        rm_fields = {}
        for rm in read_models:
            rm_name = rm.get('name')
            fields = {f.get('name'): f for f in rm.get('fields', [])}
            rm_fields[rm_name] = fields

        for wireframe in wireframes:
            wf_name = wireframe.get('name', 'Unknown')
            components = wireframe.get('components', [])

            for component in components:
                comp_type = component.get('type')
                displays = component.get('displays', [])

                # Check display components (text, list, table)
                if comp_type in ['text', 'list', 'table'] and displays:
                    for display_ref in displays:
                        # display_ref might be "ReadModelName.fieldName" or just "fieldName"
                        if '.' in display_ref:
                            rm_name, field_name = display_ref.split('.', 1)
                            if rm_name not in rm_fields:
                                issues.append(DataFlowIssue(
                                    severity='error',
                                    category='missing_source',
                                    message=f"Wireframe '{wf_name}' component displays data from non-existent read model '{rm_name}'",
                                    details={
                                        'wireframe': wf_name,
                                        'component_type': comp_type,
                                        'reference': display_ref,
                                        'available_read_models': list(rm_fields.keys())
                                    },
                                    suggestions=[
                                        f"Add read model '{rm_name}' to the event model",
                                        "Update display reference to use an existing read model",
                                        "Remove this component if it's not needed"
                                    ]
                                ))
                            elif field_name not in rm_fields[rm_name]:
                                issues.append(DataFlowIssue(
                                    severity='error',
                                    category='missing_source',
                                    message=f"Wireframe '{wf_name}' component displays non-existent field '{field_name}' from read model '{rm_name}'",
                                    details={
                                        'wireframe': wf_name,
                                        'component_type': comp_type,
                                        'reference': display_ref,
                                        'read_model': rm_name,
                                        'available_fields': list(rm_fields[rm_name].keys())
                                    },
                                    suggestions=[
                                        f"Add field '{field_name}' to read model '{rm_name}'",
                                        "Update display reference to use an existing field",
                                        "Remove this display reference if it's not needed"
                                    ]
                                ))

        return issues

    def _validate_complete_flows(self, commands: List[Dict], events: List[Any], read_models: List[Dict], wireframes: List[Dict]) -> List[DataFlowIssue]:
        """Validate that there are complete UI → Command → Event → Read Model → UI flows"""
        issues = []

        # This is a higher-level validation that checks for broken chains
        # Example: If a command parameter comes from a read model, but that read model
        # is never displayed in a wireframe that triggers the command

        # For now, we'll add this as a future enhancement
        # The individual validations above already catch most flow issues

        return issues

    def _has_ui_input_for_command(self, wireframes: List[Dict], command_name: str, param_name: str) -> bool:
        """Check if there's a wireframe input component for a command parameter"""
        for wireframe in wireframes:
            # Check if this wireframe triggers the command
            components = wireframe.get('components', [])
            triggers_command = any(
                c.get('triggers') == command_name
                for c in components
                if c.get('type') == 'button'
            )

            if triggers_command:
                # Check if there's an input for this parameter
                has_input = any(
                    c.get('field') == param_name and c.get('type') == 'input'
                    for c in components
                )
                if has_input:
                    return True

        return False

    def _read_model_field_exists(self, read_models: List[Dict], field_ref: str) -> bool:
        """Check if a read model field reference exists (format: ReadModelName.fieldName)"""
        if '.' not in field_ref:
            return False

        rm_name, field_name = field_ref.split('.', 1)

        for rm in read_models:
            if rm.get('name') == rm_name:
                fields = rm.get('fields', [])
                return any(f.get('name') == field_name for f in fields)

        return False
