"""Project generation endpoint."""

import io
import os
import zipfile
from typing import Dict, Any
from fastapi import APIRouter, Depends, HTTPException
from fastapi.responses import StreamingResponse
from pydantic import BaseModel

from app.storage.task_storage import TaskStorage
from app.api.dependencies import get_task_storage, get_current_user

router = APIRouter()


class GenerateProjectRequest(BaseModel):
    """Request model for project generation."""
    format: str = "zip"  # Only 'zip' supported initially


def generate_project_structure(tech_stack: Dict[str, Any], task_description: str) -> Dict[str, str]:
    """
    Generate project boilerplate based on tech stack.

    Returns a dictionary mapping file paths to their contents.
    """
    files = {}

    # Extract tech stack details
    app_type = tech_stack.get("application_type", "Application")
    languages = tech_stack.get("preferred_languages", ["Python"])
    frameworks = tech_stack.get("frameworks", {})

    primary_language = languages[0] if languages else "Python"

    # Generate README
    files["README.md"] = f"""# {task_description}

## Project Overview

{task_description}

## Tech Stack

- **Application Type**: {app_type}
- **Languages**: {', '.join(languages)}
- **Frameworks**:
{_format_frameworks(frameworks)}

## Getting Started

### Prerequisites

{_get_prerequisites(primary_language, frameworks)}

### Installation

```bash
# Clone the repository
git clone <your-repo-url>

# Navigate to project directory
cd {_sanitize_name(task_description)}

{_get_install_commands(primary_language, frameworks)}
```

### Running the Application

{_get_run_commands(primary_language, frameworks)}

## Project Structure

```
{_get_project_structure(primary_language, frameworks)}
```

## Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## License

This project is generated by Cahoots Project Manager.
"""

    # Add .gitignore
    files[".gitignore"] = _get_gitignore(primary_language, frameworks)

    # Generate language-specific boilerplate
    if primary_language.lower() in ["python", "python3"]:
        files.update(_generate_python_boilerplate(frameworks, task_description))
    elif primary_language.lower() in ["javascript", "typescript", "javascript/typescript"]:
        files.update(_generate_javascript_boilerplate(frameworks, task_description))
    elif primary_language.lower() in ["java"]:
        files.update(_generate_java_boilerplate(frameworks, task_description))
    else:
        # Generic boilerplate
        files["src/main.txt"] = f"# {task_description}\n\nStart building your {app_type} here!"

    return files


def _format_frameworks(frameworks: Dict[str, list]) -> str:
    """Format frameworks dict for display."""
    if not frameworks:
        return "  - None specified"

    lines = []
    for category, framework_list in frameworks.items():
        if framework_list:
            lines.append(f"  - **{category.title()}**: {', '.join(framework_list)}")

    return '\n'.join(lines) if lines else "  - None specified"


def _sanitize_name(name: str) -> str:
    """Sanitize name for directory/file usage."""
    return name.lower().replace(' ', '-').replace('/', '-')[:50]


def _get_prerequisites(language: str, frameworks: Dict[str, list]) -> str:
    """Get prerequisites based on language and frameworks."""
    lang_lower = language.lower()

    if "python" in lang_lower:
        return "- Python 3.8 or higher\n- pip package manager"
    elif "javascript" in lang_lower or "typescript" in lang_lower:
        return "- Node.js 16 or higher\n- npm or yarn package manager"
    elif "java" in lang_lower:
        return "- Java JDK 11 or higher\n- Maven or Gradle"
    else:
        return f"- {language} runtime environment"


def _get_install_commands(language: str, frameworks: Dict[str, list]) -> str:
    """Get installation commands based on language."""
    lang_lower = language.lower()

    if "python" in lang_lower:
        return "# Install dependencies\npip install -r requirements.txt"
    elif "javascript" in lang_lower or "typescript" in lang_lower:
        return "# Install dependencies\nnpm install\n# or\nyarn install"
    elif "java" in lang_lower:
        return "# Build the project\nmvn clean install\n# or\ngradle build"
    else:
        return "# Follow language-specific installation instructions"


def _get_run_commands(language: str, frameworks: Dict[str, list]) -> str:
    """Get run commands based on language."""
    lang_lower = language.lower()

    if "python" in lang_lower:
        backend_frameworks = frameworks.get("backend", [])
        if backend_frameworks and "fastapi" in str(backend_frameworks).lower():
            return "```bash\nuvicorn app.main:app --reload\n```"
        elif backend_frameworks and "flask" in str(backend_frameworks).lower():
            return "```bash\nflask run\n```"
        elif backend_frameworks and "django" in str(backend_frameworks).lower():
            return "```bash\npython manage.py runserver\n```"
        else:
            return "```bash\npython src/main.py\n```"
    elif "javascript" in lang_lower or "typescript" in lang_lower:
        return "```bash\nnpm start\n# or\nyarn start\n```"
    elif "java" in lang_lower:
        return "```bash\nmvn spring-boot:run\n# or\njava -jar target/app.jar\n```"
    else:
        return "```bash\n# Follow language-specific run instructions\n```"


def _get_project_structure(language: str, frameworks: Dict[str, list]) -> str:
    """Get project structure based on language."""
    lang_lower = language.lower()

    if "python" in lang_lower:
        return """.
├── README.md
├── requirements.txt
├── .gitignore
├── app/
│   ├── __init__.py
│   ├── main.py
│   └── config.py
└── tests/
    └── __init__.py"""
    elif "javascript" in lang_lower or "typescript" in lang_lower:
        return """.
├── README.md
├── package.json
├── .gitignore
├── src/
│   ├── index.js
│   └── config.js
└── tests/"""
    elif "java" in lang_lower:
        return """.
├── README.md
├── pom.xml
├── .gitignore
├── src/
│   ├── main/
│   │   └── java/
│   └── test/
│       └── java/"""
    else:
        return """.
├── README.md
├── .gitignore
└── src/"""


def _get_gitignore(language: str, frameworks: Dict[str, list]) -> str:
    """Generate .gitignore based on language."""
    lang_lower = language.lower()

    common = """# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Logs
*.log
logs/
"""

    if "python" in lang_lower:
        return common + """
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
venv/
env/
ENV/
.venv
pip-log.txt
pip-delete-this-directory.txt
.pytest_cache/
.coverage
htmlcov/
dist/
build/
*.egg-info/
"""
    elif "javascript" in lang_lower or "typescript" in lang_lower:
        return common + """
# Node
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.npm
.eslintcache
dist/
build/
"""
    elif "java" in lang_lower:
        return common + """
# Java
target/
*.class
*.jar
*.war
*.ear
.mvn/
mvnw
mvnw.cmd
"""
    else:
        return common


def _generate_python_boilerplate(frameworks: Dict[str, list], task_description: str) -> Dict[str, str]:
    """Generate Python project boilerplate."""
    files = {}

    backend_frameworks = frameworks.get("backend", [])
    database_frameworks = frameworks.get("database", [])

    # requirements.txt
    requirements = []
    if backend_frameworks:
        if "fastapi" in str(backend_frameworks).lower():
            requirements.extend([
                "fastapi>=0.109.0",
                "uvicorn[standard]>=0.27.0",
                "pydantic>=2.0.0",
                "pydantic-settings>=2.0.0",
                "python-jose[cryptography]>=3.3.0",
                "passlib[bcrypt]>=1.7.4",
                "python-multipart>=0.0.6"
            ])
        elif "flask" in str(backend_frameworks).lower():
            requirements.extend([
                "flask>=3.0.0",
                "flask-sqlalchemy>=3.0.0",
                "flask-jwt-extended>=4.5.0",
                "flask-cors>=4.0.0"
            ])
        elif "django" in str(backend_frameworks).lower():
            requirements.extend([
                "django>=5.0.0",
                "djangorestframework>=3.14.0",
                "djangorestframework-simplejwt>=5.3.0",
                "django-cors-headers>=4.3.0"
            ])

    # Database drivers
    if database_frameworks:
        db_str = str(database_frameworks).lower()
        if "postgresql" in db_str or "postgres" in db_str:
            requirements.append("psycopg2-binary>=2.9.0")
            requirements.append("sqlalchemy>=2.0.0")
        if "mongodb" in db_str or "mongo" in db_str:
            requirements.append("pymongo>=4.6.0")
            requirements.append("motor>=3.3.0")
        if "redis" in db_str:
            requirements.append("redis>=5.0.0")

    # Common utilities
    requirements.extend([
        "python-dotenv>=1.0.0",
        "httpx>=0.25.0",
        "pytest>=7.4.0",
        "pytest-asyncio>=0.21.0"
    ])

    if not requirements:
        requirements = ["# Add your dependencies here"]

    files["requirements.txt"] = "\n".join(requirements)

    # app/__init__.py
    files["app/__init__.py"] = '"""Main application package."""\n'

    # Environment configuration
    env_vars = [
        "# Application Settings",
        "APP_NAME=" + _sanitize_name(task_description),
        "APP_ENV=development",
        "DEBUG=True",
        "",
        "# Server Settings",
        "HOST=0.0.0.0",
        "PORT=8000",
        "",
        "# Security",
        "SECRET_KEY=change-this-to-a-secure-random-string",
        "JWT_ALGORITHM=HS256",
        "ACCESS_TOKEN_EXPIRE_MINUTES=30",
        "",
        "# Database",
    ]

    if database_frameworks:
        db_str = str(database_frameworks).lower()
        if "postgresql" in db_str or "postgres" in db_str:
            env_vars.extend([
                "DATABASE_URL=postgresql://user:password@localhost:5432/dbname",
                "POSTGRES_USER=user",
                "POSTGRES_PASSWORD=password",
                "POSTGRES_DB=dbname"
            ])
        if "mongodb" in db_str:
            env_vars.append("MONGODB_URL=mongodb://localhost:27017/dbname")
        if "redis" in db_str:
            env_vars.append("REDIS_URL=redis://localhost:6379/0")

    files[".env.example"] = "\n".join(env_vars)

    # app/main.py
    if backend_frameworks and "fastapi" in str(backend_frameworks).lower():
        files["app/main.py"] = """\"\"\"FastAPI application entry point.\"\"\"

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.api import router as api_router
from app.config import settings

app = FastAPI(
    title=settings.APP_NAME,
    description=\"Generated by Cahoots Project Manager\",
    version=\"0.1.0\",
    docs_url=\"/docs\",
    redoc_url=\"/redoc\"
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=[\"*\"],  # Configure properly for production
    allow_credentials=True,
    allow_methods=[\"*\"],
    allow_headers=[\"*\"],
)

# Include API routes
app.include_router(api_router, prefix=\"/api\")

@app.get(\"/\")
async def root():
    \"\"\"Root endpoint.\"\"\"
    return {
        \"message\": f\"Welcome to {settings.APP_NAME}\",
        \"version\": \"0.1.0\",
        \"docs\": \"/docs\"
    }

@app.get(\"/health\")
async def health():
    \"\"\"Health check endpoint.\"\"\"
    return {\"status\": \"healthy\", \"environment\": settings.APP_ENV}
"""

        # Add API module structure
        files["app/api/__init__.py"] = """\"\"\"API routes package.\"\"\"

from fastapi import APIRouter
from app.api import auth, users, posts

router = APIRouter()

router.include_router(auth.router, prefix=\"/auth\", tags=[\"Authentication\"])
router.include_router(users.router, prefix=\"/users\", tags=[\"Users\"])
router.include_router(posts.router, prefix=\"/posts\", tags=[\"Posts\"])
"""

        # Add authentication routes
        files["app/api/auth.py"] = """\"\"\"Authentication endpoints.\"\"\"

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from app.models.user import UserCreate, UserLogin, Token
from app.services.auth import create_access_token, verify_password, get_password_hash

router = APIRouter()

@router.post(\"/register\", response_model=Token)
async def register(user_data: UserCreate):
    \"\"\"Register a new user.\"\"\"
    # TODO: Check if user exists
    # TODO: Create user in database
    # TODO: Generate access token

    access_token = create_access_token(data={\"sub\": user_data.email})
    return {\"access_token\": access_token, \"token_type\": \"bearer\"}

@router.post(\"/login\", response_model=Token)
async def login(form_data: OAuth2PasswordRequestForm = Depends()):
    \"\"\"Login user and return access token.\"\"\"
    # TODO: Verify user credentials
    # TODO: Generate access token

    access_token = create_access_token(data={\"sub\": form_data.username})
    return {\"access_token\": access_token, \"token_type\": \"bearer\"}

@router.post(\"/logout\")
async def logout():
    \"\"\"Logout user.\"\"\"
    # TODO: Invalidate token (if using token blacklist)
    return {\"message\": \"Successfully logged out\"}
"""

        # Add user routes
        files["app/api/users.py"] = """\"\"\"User management endpoints.\"\"\"

from fastapi import APIRouter, Depends, HTTPException, status
from typing import List
from app.models.user import User, UserUpdate
from app.services.auth import get_current_user

router = APIRouter()

@router.get(\"/me\", response_model=User)
async def get_current_user_profile(current_user: User = Depends(get_current_user)):
    \"\"\"Get current user profile.\"\"\"
    return current_user

@router.put(\"/me\", response_model=User)
async def update_profile(
    user_update: UserUpdate,
    current_user: User = Depends(get_current_user)
):
    \"\"\"Update current user profile.\"\"\"
    # TODO: Update user in database
    return current_user

@router.get(\"/{user_id}\", response_model=User)
async def get_user(user_id: str):
    \"\"\"Get user by ID.\"\"\"
    # TODO: Fetch user from database
    raise HTTPException(status_code=404, detail=\"User not found\")

@router.get(\"/\", response_model=List[User])
async def list_users(skip: int = 0, limit: int = 10):
    \"\"\"List all users.\"\"\"
    # TODO: Fetch users from database
    return []
"""

        # Add posts routes
        files["app/api/posts.py"] = """\"\"\"Post management endpoints.\"\"\"

from fastapi import APIRouter, Depends, HTTPException, status
from typing import List
from app.models.post import Post, PostCreate, PostUpdate
from app.models.user import User
from app.services.auth import get_current_user

router = APIRouter()

@router.post(\"/\", response_model=Post, status_code=status.HTTP_201_CREATED)
async def create_post(
    post_data: PostCreate,
    current_user: User = Depends(get_current_user)
):
    \"\"\"Create a new post.\"\"\"
    # TODO: Create post in database
    return Post(**post_data.dict(), id=\"post_id\", author_id=current_user.id)

@router.get(\"/{post_id}\", response_model=Post)
async def get_post(post_id: str):
    \"\"\"Get post by ID.\"\"\"
    # TODO: Fetch post from database
    raise HTTPException(status_code=404, detail=\"Post not found\")

@router.put(\"/{post_id}\", response_model=Post)
async def update_post(
    post_id: str,
    post_update: PostUpdate,
    current_user: User = Depends(get_current_user)
):
    \"\"\"Update a post.\"\"\"
    # TODO: Verify post ownership
    # TODO: Update post in database
    raise HTTPException(status_code=404, detail=\"Post not found\")

@router.delete(\"/{post_id}\", status_code=status.HTTP_204_NO_CONTENT)
async def delete_post(
    post_id: str,
    current_user: User = Depends(get_current_user)
):
    \"\"\"Delete a post.\"\"\"
    # TODO: Verify post ownership
    # TODO: Delete post from database
    return None

@router.get(\"/\", response_model=List[Post])
async def list_posts(skip: int = 0, limit: int = 20):
    \"\"\"List all posts.\"\"\"
    # TODO: Fetch posts from database
    return []

@router.post(\"/{post_id}/like\")
async def like_post(
    post_id: str,
    current_user: User = Depends(get_current_user)
):
    \"\"\"Like a post.\"\"\"
    # TODO: Add like to database
    return {\"message\": \"Post liked\"}

@router.delete(\"/{post_id}/like\")
async def unlike_post(
    post_id: str,
    current_user: User = Depends(get_current_user)
):
    \"\"\"Unlike a post.\"\"\"
    # TODO: Remove like from database
    return {\"message\": \"Post unliked\"}
"""

        # Add models
        files["app/models/__init__.py"] = '"""Data models package."""\n'

        files["app/models/user.py"] = """\"\"\"User data models.\"\"\"

from pydantic import BaseModel, EmailStr, Field
from typing import Optional
from datetime import datetime

class UserBase(BaseModel):
    email: EmailStr
    username: str
    full_name: Optional[str] = None

class UserCreate(UserBase):
    password: str = Field(..., min_length=8)

class UserLogin(BaseModel):
    email: EmailStr
    password: str

class UserUpdate(BaseModel):
    full_name: Optional[str] = None
    bio: Optional[str] = None
    avatar_url: Optional[str] = None

class User(UserBase):
    id: str
    bio: Optional[str] = None
    avatar_url: Optional[str] = None
    is_active: bool = True
    created_at: datetime

    class Config:
        from_attributes = True

class Token(BaseModel):
    access_token: str
    token_type: str
"""

        files["app/models/post.py"] = """\"\"\"Post data models.\"\"\"

from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime

class PostBase(BaseModel):
    content: str = Field(..., min_length=1, max_length=5000)
    media_urls: Optional[List[str]] = []

class PostCreate(PostBase):
    pass

class PostUpdate(BaseModel):
    content: Optional[str] = Field(None, min_length=1, max_length=5000)

class Post(PostBase):
    id: str
    author_id: str
    likes_count: int = 0
    comments_count: int = 0
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True
"""

        # Add services
        files["app/services/__init__.py"] = '"""Business logic services."""\n'

        files["app/services/auth.py"] = """\"\"\"Authentication service.\"\"\"

from datetime import datetime, timedelta
from typing import Optional
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from app.config import settings

pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"api/auth/login\")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    \"\"\"Verify a password against a hash.\"\"\"
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    \"\"\"Hash a password.\"\"\"
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    \"\"\"Create a JWT access token.\"\"\"
    to_encode = data.copy()

    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)

    to_encode.update({\"exp\": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.JWT_ALGORITHM)
    return encoded_jwt

async def get_current_user(token: str = Depends(oauth2_scheme)):
    \"\"\"Get current user from JWT token.\"\"\"
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail=\"Could not validate credentials\",
        headers={\"WWW-Authenticate\": \"Bearer\"},
    )

    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.JWT_ALGORITHM])
        user_id: str = payload.get(\"sub\")
        if user_id is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception

    # TODO: Fetch user from database
    # For now, return a mock user
    from app.models.user import User
    return User(
        id=user_id,
        email=user_id,
        username=user_id.split(\"@\")[0],
        created_at=datetime.utcnow()
    )
"""

        # Add database module
        files["app/database/__init__.py"] = '"""Database connection and models."""\n'

        if database_frameworks and "postgresql" in str(database_frameworks).lower():
            files["app/database/connection.py"] = """\"\"\"Database connection setup.\"\"\"

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from sqlalchemy.orm import declarative_base
from app.config import settings

# Create async engine
engine = create_async_engine(
    settings.DATABASE_URL.replace(\"postgresql://\", \"postgresql+asyncpg://\"),
    echo=settings.DEBUG,
    future=True
)

# Create async session factory
AsyncSessionLocal = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False
)

# Base class for models
Base = declarative_base()

async def get_db():
    \"\"\"Dependency for getting database sessions.\"\"\"
    async with AsyncSessionLocal() as session:
        try:
            yield session
        finally:
            await session.close()

async def init_db():
    \"\"\"Initialize database tables.\"\"\"
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
"""

            files["app/database/models.py"] = """\"\"\"SQLAlchemy database models.\"\"\"

from sqlalchemy import Column, String, Boolean, DateTime, Integer, Text, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from app.database.connection import Base

class User(Base):
    __tablename__ = \"users\"

    id = Column(String, primary_key=True, index=True)
    email = Column(String, unique=True, index=True, nullable=False)
    username = Column(String, unique=True, index=True, nullable=False)
    full_name = Column(String, nullable=True)
    hashed_password = Column(String, nullable=False)
    bio = Column(Text, nullable=True)
    avatar_url = Column(String, nullable=True)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

    posts = relationship(\"Post\", back_populates=\"author\")

class Post(Base):
    __tablename__ = \"posts\"

    id = Column(String, primary_key=True, index=True)
    content = Column(Text, nullable=False)
    author_id = Column(String, ForeignKey(\"users.id\"), nullable=False)
    likes_count = Column(Integer, default=0)
    comments_count = Column(Integer, default=0)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    author = relationship(\"User\", back_populates=\"posts\")
"""

    else:
        files["app/main.py"] = """\"\"\"Main application entry point.\"\"\"

def main():
    \"\"\"Main function.\"\"\"
    print(\"Welcome to """ + task_description + """\")

if __name__ == "__main__":
    main()
"""

    # app/config.py
    files["app/config.py"] = """\"\"\"Application configuration.\"\"\"

from pydantic_settings import BaseSettings
from typing import Optional

class Settings(BaseSettings):
    \"\"\"Application settings loaded from environment variables.\"\"\"

    # Application
    APP_NAME: str = \"Application\"
    APP_ENV: str = \"development\"
    DEBUG: bool = True

    # Server
    HOST: str = \"0.0.0.0\"
    PORT: int = 8000

    # Security
    SECRET_KEY: str = \"change-this-to-a-secure-random-string\"
    JWT_ALGORITHM: str = \"HS256\"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30

    # Database
    DATABASE_URL: Optional[str] = None
    MONGODB_URL: Optional[str] = None
    REDIS_URL: Optional[str] = None

    class Config:
        env_file = \".env\"
        case_sensitive = True

settings = Settings()
"""

    # tests/__init__.py
    files["tests/__init__.py"] = '"""Test package."""\n'

    # Add Docker support
    files["Dockerfile"] = """# Multi-stage Dockerfile for Python application
FROM python:3.11-slim as builder

WORKDIR /app

# Install dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir --user -r requirements.txt

# Final stage
FROM python:3.11-slim

WORKDIR /app

# Copy dependencies from builder
COPY --from=builder /root/.local /root/.local

# Copy application code
COPY . .

# Make sure scripts in .local are usable
ENV PATH=/root/.local/bin:$PATH

# Expose port
EXPOSE 8000

# Run the application
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
"""

    files["docker-compose.yml"] = """version: '3.8'

services:
  app:
    build: .
    ports:
      - "8000:8000"
    environment:
      - APP_ENV=development
      - DATABASE_URL=postgresql://user:password@postgres:5432/dbname
      - REDIS_URL=redis://redis:6379/0
    depends_on:
      - postgres
      - redis
    volumes:
      - .:/app
    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload

  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=dbname
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
"""

    # Add alembic for migrations if PostgreSQL
    if database_frameworks and "postgresql" in str(database_frameworks).lower():
        files["alembic.ini"] = """# A generic, single database configuration.

[alembic]
script_location = alembic
prepend_sys_path = .
version_path_separator = os
sqlalchemy.url = postgresql://user:password@localhost:5432/dbname

[post_write_hooks]

[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S
"""

        files["alembic/env.py"] = """from logging.config import fileConfig

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context
from app.database.connection import Base
from app.database.models import *  # Import all models
from app.config import settings

# this is the Alembic Config object
config = context.config

# Update SQLAlchemy URL from settings
config.set_main_option('sqlalchemy.url', settings.DATABASE_URL)

# Interpret the config file for Python logging
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

target_metadata = Base.metadata

def run_migrations_offline() -> None:
    \"\"\"Run migrations in 'offline' mode.\"\"\"
    url = config.get_main_option(\"sqlalchemy.url\")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={\"paramstyle\": \"named\"},
    )

    with context.begin_transaction():
        context.run_migrations()

def run_migrations_online() -> None:
    \"\"\"Run migrations in 'online' mode.\"\"\"
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix=\"sqlalchemy.\",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()

if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
"""

        # Add alembic to requirements
        requirements.append("alembic>=1.13.0")
        files["requirements.txt"] = "\n".join(requirements)

    return files


def _generate_javascript_boilerplate(frameworks: Dict[str, list], task_description: str) -> Dict[str, str]:
    """Generate JavaScript/Node.js project boilerplate."""
    files = {}

    frontend_frameworks = frameworks.get("frontend", [])
    backend_frameworks = frameworks.get("backend", [])

    # package.json
    dependencies = {}
    scripts = {}

    if frontend_frameworks and "react" in str(frontend_frameworks).lower():
        dependencies.update({
            "react": "^18.2.0",
            "react-dom": "^18.2.0"
        })
        scripts["start"] = "react-scripts start"
        scripts["build"] = "react-scripts build"
    elif backend_frameworks and "express" in str(backend_frameworks).lower():
        dependencies["express"] = "^4.18.0"
        scripts["start"] = "node src/index.js"
        scripts["dev"] = "nodemon src/index.js"
    else:
        scripts["start"] = "node src/index.js"

    package_json = {
        "name": _sanitize_name(task_description),
        "version": "0.1.0",
        "description": task_description,
        "main": "src/index.js",
        "scripts": scripts,
        "dependencies": dependencies,
        "devDependencies": {},
        "keywords": [],
        "author": "",
        "license": "ISC"
    }

    import json
    files["package.json"] = json.dumps(package_json, indent=2)

    # src/index.js
    if backend_frameworks and "express" in str(backend_frameworks).lower():
        files["src/index.js"] = """const express = require('express');
const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());

app.get('/', (req, res) => {
  res.json({ message: 'Welcome to """ + task_description + """' });
});

app.get('/health', (req, res) => {
  res.json({ status: 'healthy' });
});

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
"""
    else:
        files["src/index.js"] = """console.log('Welcome to """ + task_description + """');

// Add your code here
"""

    # src/config.js
    files["src/config.js"] = """module.exports = {
  env: process.env.NODE_ENV || 'development',
  port: process.env.PORT || 3000,
  // Add your configuration here
};
"""

    return files


def _generate_java_boilerplate(frameworks: Dict[str, list], task_description: str) -> Dict[str, str]:
    """Generate Java project boilerplate."""
    files = {}

    # pom.xml (Maven)
    files["pom.xml"] = """<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>""" + _sanitize_name(task_description) + """</artifactId>
    <version>0.1.0</version>
    <packaging>jar</packaging>

    <name>""" + task_description + """</name>
    <description>Generated by Cahoots Project Manager</description>

    <properties>
        <java.version>11</java.version>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
    </properties>

    <dependencies>
        <!-- Add your dependencies here -->
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.1</version>
            </plugin>
        </plugins>
    </build>
</project>
"""

    # src/main/java/com/example/Main.java
    files["src/main/java/com/example/Main.java"] = """package com.example;

public class Main {
    public static void main(String[] args) {
        System.out.println("Welcome to """ + task_description + """");
    }
}
"""

    return files


@router.post("/tasks/{task_id}/generate-project")
async def generate_project(
    task_id: str,
    request: GenerateProjectRequest,
    storage: TaskStorage = Depends(get_task_storage),
    current_user: dict = Depends(get_current_user)
):
    """Generate project boilerplate and return as ZIP file."""

    # Get task from storage
    task = await storage.get_task(task_id)
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")

    # Get tech stack from context
    tech_stack = task.context.get("tech_stack", {})
    if not tech_stack:
        raise HTTPException(
            status_code=400,
            detail="No tech stack information available for this task"
        )

    # Generate project structure
    files = generate_project_structure(tech_stack, task.description)

    # Create ZIP file in memory
    zip_buffer = io.BytesIO()
    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
        for file_path, content in files.items():
            zip_file.writestr(file_path, content)

    # Prepare response
    zip_buffer.seek(0)
    filename = f"{_sanitize_name(task.description)}-project.zip"

    return StreamingResponse(
        zip_buffer,
        media_type="application/zip",
        headers={
            "Content-Disposition": f"attachment; filename={filename}"
        }
    )
