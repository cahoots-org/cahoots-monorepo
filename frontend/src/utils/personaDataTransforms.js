/**
 * personaDataTransforms.js
 *
 * Utility functions to transform task data into persona-specific views.
 */

/**
 * Calculate story point metrics for PM view
 * Story points are on the tasks themselves (in the tree), not on story objects
 */
export const calculateStoryPointMetrics = (task, taskTree) => {
  const epics = task?.context?.epics || task?.metadata?.epics || [];
  const stories = task?.context?.user_stories || task?.metadata?.user_stories || [];

  // Sum story points from the task tree (tasks have story_points field)
  let totalPoints = 0;
  let atomicTasks = 0;

  const sumPoints = (node) => {
    if (!node) return;
    if (node.story_points) {
      totalPoints += node.story_points;
    }
    if (node.is_atomic) {
      atomicTasks++;
    }
    (node.children || []).forEach(sumPoints);
  };
  sumPoints(taskTree);

  return {
    totalPoints,
    epicCount: epics.length,
    storyCount: stories.length,
    atomicTasks,
  };
};

/**
 * Group stories by epic for PM overview
 * Stories have epic_id field (e.g., "EP-1"), epics have id field
 */
export const groupStoriesByEpic = (task) => {
  const epics = task?.context?.epics || task?.metadata?.epics || [];
  const stories = task?.context?.user_stories || task?.metadata?.user_stories || [];

  return epics.map((epic) => {
    const epicId = epic.id; // e.g., "EP-1"
    const epicStories = stories.filter((s) => s.epic_id === epicId);
    return {
      ...epic,
      name: epic.title || epic.name, // normalize to 'name' for display
      stories: epicStories,
    };
  });
};

/**
 * Extract event model components for Dev view
 */
export const extractEventModelComponents = (task) => {
  const metadata = task?.metadata || {};
  const events = metadata.extracted_events || [];
  const commands = metadata.commands || [];
  const readModels = metadata.read_models || [];
  const swimlanes = metadata.swimlanes || [];

  const normalizeItem = (item) => {
    if (typeof item === 'string') {
      return { name: item, description: '' };
    }
    return {
      name: item.name || item.title || 'Unknown',
      description: item.description || '',
      ...item,
    };
  };

  return {
    events: events.map(normalizeItem),
    commands: commands.map(normalizeItem),
    readModels: readModels.map(normalizeItem),
    swimlanes: swimlanes.map(normalizeItem),
    summary: {
      eventCount: events.length,
      commandCount: commands.length,
      readModelCount: readModels.length,
    },
  };
};

/**
 * Extract GWT scenarios for Dev view
 * Looks in multiple places:
 * 1. User stories with gwt_scenarios
 * 2. Acceptance criteria in GWT format
 * 3. Slices from chapters (generated by swimlane detector)
 */
export const extractGWTScenarios = (task) => {
  const scenarios = [];

  // Source 1: User stories with GWT scenarios
  const stories = task?.context?.user_stories || task?.metadata?.user_stories || [];
  stories.forEach((story) => {
    const storyTitle = story.title || story.name ||
      (story.actor && story.action ? `${story.actor} - ${story.action}` : 'Untitled Story');

    if (story.gwt_scenarios && Array.isArray(story.gwt_scenarios)) {
      story.gwt_scenarios.forEach((scenario) => {
        scenarios.push({
          storyTitle,
          given: scenario.given || '',
          when: scenario.when || '',
          then: scenario.then || '',
        });
      });
    }

    // Check acceptance_criteria for GWT format
    if (story.acceptance_criteria && Array.isArray(story.acceptance_criteria)) {
      story.acceptance_criteria.forEach((criteria) => {
        if (typeof criteria === 'object' && (criteria.given || criteria.when || criteria.then)) {
          scenarios.push({
            storyTitle,
            given: criteria.given || '',
            when: criteria.when || '',
            then: criteria.then || '',
          });
        }
      });
    }
  });

  // Source 2: Slices from chapters (swimlane detector generates these)
  const chapters = task?.metadata?.chapters || [];
  chapters.forEach((chapter) => {
    const slices = chapter?.slices || [];
    slices.forEach((slice) => {
      if (slice.gwt_scenarios && Array.isArray(slice.gwt_scenarios)) {
        const sliceName = slice.command || slice.read_model || slice.automation_name || 'Unknown Slice';
        slice.gwt_scenarios.forEach((scenario) => {
          scenarios.push({
            storyTitle: sliceName,
            given: scenario.given || '',
            when: scenario.when || '',
            then: scenario.then || '',
          });
        });
      }
    });
  });

  return scenarios;
};

/**
 * Transform technical event names into business-friendly capability names
 * "EmailVerificationSent" â†’ "Email verification"
 * "UserRegistered" â†’ "User registration"
 * "RecipeCreated" â†’ "Recipe creation"
 */
const toBusinessCapability = (technicalName) => {
  if (!technicalName) return '';

  // Split camelCase/PascalCase into words
  let words = technicalName
    .replace(/([A-Z])/g, ' $1')
    .trim()
    .split(/\s+/);

  // Remove common technical suffixes that don't add business value
  const technicalSuffixes = [
    'Event', 'Command', 'Handler', 'Service', 'Repository',
    'Created', 'Updated', 'Deleted', 'Sent', 'Received',
    'Started', 'Completed', 'Failed', 'Processed', 'View',
    'Display', 'Screen', 'Page', 'Model', 'Query'
  ];

  // Convert past tense verbs to noun form for better readability
  const pastToNoun = {
    'registered': 'registration',
    'created': 'creation',
    'updated': 'updates',
    'deleted': 'deletion',
    'sent': 'sending',
    'received': 'receipt',
    'verified': 'verification',
    'authenticated': 'authentication',
    'processed': 'processing',
    'completed': 'completion',
    'failed': 'failure',
    'added': 'addition',
    'removed': 'removal',
    'changed': 'changes',
    'modified': 'modifications',
    'saved': 'saving',
    'loaded': 'loading',
    'fetched': 'fetching',
    'submitted': 'submission',
    'cancelled': 'cancellation',
    'approved': 'approval',
    'rejected': 'rejection',
    'published': 'publishing',
    'archived': 'archiving',
  };

  // Remove technical suffixes and convert
  words = words.filter(w => !technicalSuffixes.includes(w));

  // Convert last word if it's a past tense verb
  if (words.length > 0) {
    const lastWord = words[words.length - 1].toLowerCase();
    if (pastToNoun[lastWord]) {
      words[words.length - 1] = pastToNoun[lastWord];
    }
  }

  // Join and format nicely
  return words.join(' ').toLowerCase().replace(/^\w/, c => c.toUpperCase());
};

/**
 * Extract domain/aggregate from a technical name
 * "UserRegistered" â†’ "User"
 * "RecipeCreated" â†’ "Recipe"
 * "MealPlanGenerated" â†’ "Meal Plan"
 */
const extractDomain = (name) => {
  if (!name) return 'General';

  // Common domain patterns - extract the first noun
  const domainPatterns = [
    /^(User|Account|Profile|Auth)/i,
    /^(Recipe|Ingredient|Cuisine)/i,
    /^(Meal|Menu|Plan|Schedule)/i,
    /^(Grocery|Shopping|Cart|List)/i,
    /^(Cookbook|Collection|Favorite)/i,
    /^(Email|Notification|Alert)/i,
    /^(Payment|Subscription|Billing)/i,
    /^(Admin|Settings|Config)/i,
  ];

  for (const pattern of domainPatterns) {
    const match = name.match(pattern);
    if (match) {
      // Format: "MealPlan" â†’ "Meal Plan"
      return match[1].replace(/([a-z])([A-Z])/g, '$1 $2');
    }
  }

  // Default: take first word (usually the domain)
  const firstWord = name.replace(/([A-Z])/g, ' $1').trim().split(/\s+/)[0];
  return firstWord || 'General';
};

/**
 * Aggregate event model data by business domain for consultant view
 * Groups swimlanes, events, commands by their domain (User, Recipe, etc.)
 * Returns business-friendly capability descriptions
 */
export const aggregateByBusinessDomain = (task) => {
  const metadata = task?.metadata || {};
  const swimlanes = metadata.swimlanes || [];
  const events = metadata.extracted_events || [];
  const commands = metadata.commands || [];
  const readModels = metadata.read_models || [];

  // Domain map: { "User": { capabilities: Set, actions: Set, views: Set } }
  const domains = new Map();

  const ensureDomain = (domainName) => {
    if (!domains.has(domainName)) {
      domains.set(domainName, {
        name: domainName,
        description: '',
        capabilities: new Set(),
        actions: new Set(),
        views: new Set(),
        automations: new Set(),
      });
    }
    return domains.get(domainName);
  };

  // Process swimlanes (best source - already grouped by domain)
  swimlanes.forEach(sw => {
    const domainName = sw.name || 'General';
    const domain = ensureDomain(domainName);

    if (sw.description) {
      domain.description = sw.description;
    }

    // Convert commands to business actions
    (sw.commands || []).forEach(cmd => {
      const action = toBusinessCapability(cmd);
      if (action && action.length > 2) {
        domain.actions.add(action);
      }
    });

    // Convert read models to views
    (sw.read_models || []).forEach(rm => {
      const view = toBusinessCapability(rm);
      if (view && view.length > 2) {
        domain.views.add(view);
      }
    });

    // Convert automations to background capabilities
    (sw.automations || []).forEach(auto => {
      const automation = toBusinessCapability(auto);
      if (automation && automation.length > 2) {
        domain.automations.add(automation);
      }
    });
  });

  // If no swimlanes, build from raw events/commands
  if (swimlanes.length === 0) {
    // Group events by domain
    events.forEach(evt => {
      const evtName = typeof evt === 'string' ? evt : evt.name;
      const domainName = extractDomain(evtName);
      const domain = ensureDomain(domainName);
      const capability = toBusinessCapability(evtName);
      if (capability && capability.length > 2) {
        domain.capabilities.add(capability);
      }
    });

    // Group commands by domain
    commands.forEach(cmd => {
      const cmdName = typeof cmd === 'string' ? cmd : cmd.name;
      const domainName = extractDomain(cmdName);
      const domain = ensureDomain(domainName);
      const action = toBusinessCapability(cmdName);
      if (action && action.length > 2) {
        domain.actions.add(action);
      }
    });

    // Group read models by domain
    readModels.forEach(rm => {
      const rmName = typeof rm === 'string' ? rm : rm.name;
      const domainName = extractDomain(rmName);
      const domain = ensureDomain(domainName);
      const view = toBusinessCapability(rmName);
      if (view && view.length > 2) {
        domain.views.add(view);
      }
    });
  }

  // Convert Map to array and Sets to arrays
  return Array.from(domains.values()).map(domain => ({
    name: domain.name,
    description: domain.description,
    actions: Array.from(domain.actions),
    views: Array.from(domain.views),
    automations: Array.from(domain.automations),
    capabilities: Array.from(domain.capabilities),
  })).filter(d =>
    // Filter out empty domains
    d.actions.length > 0 || d.views.length > 0 ||
    d.automations.length > 0 || d.capabilities.length > 0
  );
};

/**
 * Generate executive summary for consultant proposals
 */
export const generateExecutiveSummary = (task, taskTree) => {
  const domains = aggregateByBusinessDomain(task);
  const metrics = calculateScopeMetrics(task, taskTree);

  // Build a high-level summary
  const domainNames = domains.map(d => d.name).slice(0, 5);
  const totalCapabilities = domains.reduce((sum, d) =>
    sum + d.actions.length + d.views.length + d.automations.length, 0
  );

  let summary = `This project delivers a comprehensive solution spanning ${domains.length} core business areas`;

  if (domainNames.length > 0) {
    summary += ` including ${domainNames.slice(0, 3).join(', ')}`;
    if (domainNames.length > 3) {
      summary += `, and ${domainNames.length - 3} more`;
    }
  }

  summary += `. The system provides ${totalCapabilities} distinct capabilities`;

  if (metrics.storyCount > 0) {
    summary += ` across ${metrics.storyCount} user stories`;
  }

  summary += '.';

  return summary;
};

/**
 * Calculate scope metrics for Consultant view
 */
export const calculateScopeMetrics = (task, taskTree) => {
  const epics = task?.context?.epics || task?.metadata?.epics || [];
  const stories = task?.context?.user_stories || task?.metadata?.user_stories || [];
  const metadata = task?.metadata || {};
  const events = metadata.extracted_events || [];
  const commands = metadata.commands || [];

  let totalTasks = 0;
  const countTasks = (node) => {
    if (!node) return;
    totalTasks++;
    (node.children || []).forEach(countTasks);
  };
  countTasks(taskTree);

  // Simple complexity rating
  const featureCount = epics.length + stories.length;
  let complexityRating = 'Small';
  if (featureCount > 30) complexityRating = 'Large';
  else if (featureCount > 15) complexityRating = 'Medium';

  return {
    epicCount: epics.length,
    storyCount: stories.length,
    totalTasks,
    complexityRating,
    eventCount: events.length,
    commandCount: commands.length,
  };
};

/**
 * Generate proposal markdown for Consultant export
 * Uses business-friendly domain aggregation instead of raw technical data
 */
export const generateProposalMarkdown = (task, taskTree) => {
  const businessDomains = aggregateByBusinessDomain(task);
  const epics = task?.context?.epics || task?.metadata?.epics || [];
  const stories = task?.context?.user_stories || task?.metadata?.user_stories || [];
  const requirements = task?.metadata?.requirements || {};
  const execSummary = generateExecutiveSummary(task, taskTree);

  let md = `# Project Proposal\n\n`;

  // Executive Summary section
  md += `## Executive Summary\n\n`;
  md += `${task?.description || 'No description provided.'}\n\n`;
  md += `${execSummary}\n\n`;

  // Business Capabilities section - aggregated by domain
  if (businessDomains.length > 0) {
    md += `## Business Capabilities\n\n`;
    businessDomains.forEach((domain) => {
      md += `### ${domain.name}\n\n`;
      if (domain.description) {
        md += `${domain.description}\n\n`;
      }

      if (domain.actions.length > 0) {
        md += `**What users can do:**\n`;
        domain.actions.forEach(action => {
          md += `- ${action}\n`;
        });
        md += `\n`;
      }

      if (domain.views.length > 0) {
        md += `**What users see:**\n`;
        domain.views.forEach(view => {
          md += `- ${view}\n`;
        });
        md += `\n`;
      }

      if (domain.automations.length > 0) {
        md += `**Automatic behaviors:**\n`;
        domain.automations.forEach(auto => {
          md += `- ${auto}\n`;
        });
        md += `\n`;
      }

      // For domains built from raw events (no swimlanes)
      if (domain.capabilities.length > 0 && domain.actions.length === 0) {
        md += `**Key capabilities:**\n`;
        domain.capabilities.forEach(cap => {
          md += `- ${cap}\n`;
        });
        md += `\n`;
      }
    });
  } else if (epics.length > 0) {
    // Fallback to epics if no event model data
    md += `## Features\n\n`;
    epics.forEach((epic, i) => {
      const epicTitle = epic.title || epic.name || 'Unnamed Feature';
      md += `### ${i + 1}. ${epicTitle}\n\n`;
      md += `${epic.description || ''}\n\n`;

      const epicStories = stories.filter((s) => s.epic_id === epic.id);
      if (epicStories.length > 0) {
        md += `**User Stories:**\n`;
        epicStories.forEach((story) => {
          const storyTitle = story.title || story.name ||
            (story.actor && story.action ? `As a ${story.actor}, ${story.action}` : 'Untitled');
          md += `- ${storyTitle}\n`;
        });
        md += `\n`;
      }
    });
  }

  // Requirements section if available
  const funcReqs = requirements.functional_requirements || [];
  const nonFuncReqs = requirements.non_functional_requirements || [];

  if (funcReqs.length > 0 || nonFuncReqs.length > 0) {
    md += `## Requirements\n\n`;

    if (funcReqs.length > 0) {
      md += `### Functional Requirements\n\n`;
      funcReqs.forEach(req => {
        md += `- **${req.id}** (${req.category}): ${req.requirement}\n`;
      });
      md += `\n`;
    }

    if (nonFuncReqs.length > 0) {
      md += `### Non-Functional Requirements\n\n`;
      nonFuncReqs.forEach(req => {
        md += `- **${req.id}** (${req.category}): ${req.requirement}\n`;
      });
      md += `\n`;
    }
  }

  md += `---\n*Generated by Cahoots*\n`;
  return md;
};

/**
 * Format for JIRA CSV export
 */
export const formatForJiraCSV = (task) => {
  const epics = task?.context?.epics || task?.metadata?.epics || [];
  const stories = task?.context?.user_stories || task?.metadata?.user_stories || [];

  const rows = [];
  rows.push(['Issue Type', 'Summary', 'Description', 'Epic Link', 'Story Points']);

  // Epics
  epics.forEach((epic) => {
    rows.push([
      'Epic',
      epic.title || epic.name || '',
      epic.description || '',
      '',
      '',
    ]);
  });

  // Stories
  stories.forEach((story) => {
    const summary = story.title || story.name ||
      (story.actor && story.action ? `As a ${story.actor}, ${story.action}` : '');
    const description = story.benefit ? `${summary} ${story.benefit}` : (story.description || '');

    rows.push([
      'Story',
      summary,
      description,
      story.epic_id || '',
      story.story_points || '',
    ]);
  });

  return rows.map(row =>
    row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(',')
  ).join('\n');
};

/**
 * Get persona-specific tabs
 */
export const getPersonaTabs = (persona) => {
  const tabs = {
    pm: [
      { id: 'overview', label: 'Overview', icon: 'ğŸ“Š' },
      { id: 'export', label: 'Export', icon: 'ğŸ“¤' },
    ],
    dev: [
      { id: 'eventmodel', label: 'Event Model', icon: 'ğŸ”„' },
      { id: 'scenarios', label: 'Scenarios', icon: 'ğŸ§ª' },
    ],
    consultant: [
      { id: 'scope', label: 'Scope', icon: 'ğŸ“' },
      { id: 'requirements', label: 'Requirements', icon: 'ğŸ“‹' },
      { id: 'proposal', label: 'Proposal', icon: 'ğŸ“„' },
    ],
  };

  return tabs[persona] || tabs.pm;
};
