/**
 * personaDataTransforms.js
 *
 * Utility functions to transform task data into persona-specific views.
 */

/**
 * Calculate story point metrics for PM view
 * Story points are on the tasks themselves (in the tree), not on story objects
 */
export const calculateStoryPointMetrics = (task, taskTree) => {
  const epics = task?.context?.epics || task?.metadata?.epics || [];
  const stories = task?.context?.user_stories || task?.metadata?.user_stories || [];

  // Sum story points from the task tree (tasks have story_points field)
  let totalPoints = 0;
  let atomicTasks = 0;

  const sumPoints = (node) => {
    if (!node) return;
    if (node.story_points) {
      totalPoints += node.story_points;
    }
    if (node.is_atomic) {
      atomicTasks++;
    }
    (node.children || []).forEach(sumPoints);
  };
  sumPoints(taskTree);

  return {
    totalPoints,
    epicCount: epics.length,
    storyCount: stories.length,
    atomicTasks,
  };
};

/**
 * Group stories by epic for PM overview
 * Stories have epic_id field (e.g., "EP-1"), epics have id field
 */
export const groupStoriesByEpic = (task) => {
  const epics = task?.context?.epics || task?.metadata?.epics || [];
  const stories = task?.context?.user_stories || task?.metadata?.user_stories || [];

  return epics.map((epic) => {
    const epicId = epic.id; // e.g., "EP-1"
    const epicStories = stories.filter((s) => s.epic_id === epicId);
    return {
      ...epic,
      name: epic.title || epic.name, // normalize to 'name' for display
      stories: epicStories,
    };
  });
};

/**
 * Extract event model components for Dev view
 */
export const extractEventModelComponents = (task) => {
  const metadata = task?.metadata || {};
  const events = metadata.extracted_events || [];
  const commands = metadata.commands || [];
  const readModels = metadata.read_models || [];
  const swimlanes = metadata.swimlanes || [];

  const normalizeItem = (item) => {
    if (typeof item === 'string') {
      return { name: item, description: '' };
    }
    return {
      name: item.name || item.title || 'Unknown',
      description: item.description || '',
      ...item,
    };
  };

  return {
    events: events.map(normalizeItem),
    commands: commands.map(normalizeItem),
    readModels: readModels.map(normalizeItem),
    swimlanes: swimlanes.map(normalizeItem),
    summary: {
      eventCount: events.length,
      commandCount: commands.length,
      readModelCount: readModels.length,
    },
  };
};

/**
 * Extract GWT scenarios for Dev view
 * Looks in multiple places:
 * 1. User stories with gwt_scenarios
 * 2. Acceptance criteria in GWT format
 * 3. Slices from chapters (generated by swimlane detector)
 */
export const extractGWTScenarios = (task) => {
  const scenarios = [];

  // Source 1: User stories with GWT scenarios
  const stories = task?.context?.user_stories || task?.metadata?.user_stories || [];
  stories.forEach((story) => {
    const storyTitle = story.title || story.name ||
      (story.actor && story.action ? `${story.actor} - ${story.action}` : 'Untitled Story');

    if (story.gwt_scenarios && Array.isArray(story.gwt_scenarios)) {
      story.gwt_scenarios.forEach((scenario) => {
        scenarios.push({
          storyTitle,
          given: scenario.given || '',
          when: scenario.when || '',
          then: scenario.then || '',
        });
      });
    }

    // Check acceptance_criteria for GWT format
    if (story.acceptance_criteria && Array.isArray(story.acceptance_criteria)) {
      story.acceptance_criteria.forEach((criteria) => {
        if (typeof criteria === 'object' && (criteria.given || criteria.when || criteria.then)) {
          scenarios.push({
            storyTitle,
            given: criteria.given || '',
            when: criteria.when || '',
            then: criteria.then || '',
          });
        }
      });
    }
  });

  // Source 2: Slices from chapters (swimlane detector generates these)
  const chapters = task?.metadata?.chapters || [];
  chapters.forEach((chapter) => {
    const slices = chapter?.slices || [];
    slices.forEach((slice) => {
      if (slice.gwt_scenarios && Array.isArray(slice.gwt_scenarios)) {
        const sliceName = slice.command || slice.read_model || slice.automation_name || 'Unknown Slice';
        slice.gwt_scenarios.forEach((scenario) => {
          scenarios.push({
            storyTitle: sliceName,
            given: scenario.given || '',
            when: scenario.when || '',
            then: scenario.then || '',
          });
        });
      }
    });
  });

  return scenarios;
};

/**
 * Calculate scope metrics for Consultant view
 */
export const calculateScopeMetrics = (task, taskTree) => {
  const epics = task?.context?.epics || task?.metadata?.epics || [];
  const stories = task?.context?.user_stories || task?.metadata?.user_stories || [];
  const metadata = task?.metadata || {};
  const events = metadata.extracted_events || [];
  const commands = metadata.commands || [];

  let totalTasks = 0;
  const countTasks = (node) => {
    if (!node) return;
    totalTasks++;
    (node.children || []).forEach(countTasks);
  };
  countTasks(taskTree);

  // Simple complexity rating
  const featureCount = epics.length + stories.length;
  let complexityRating = 'Small';
  if (featureCount > 30) complexityRating = 'Large';
  else if (featureCount > 15) complexityRating = 'Medium';

  return {
    epicCount: epics.length,
    storyCount: stories.length,
    totalTasks,
    complexityRating,
    eventCount: events.length,
    commandCount: commands.length,
  };
};

/**
 * Generate proposal markdown for Consultant export
 * Focuses on capabilities - what the product DOES, not counts
 */
export const generateProposalMarkdown = (task, taskTree) => {
  const swimlanes = task?.metadata?.swimlanes || [];
  const epics = task?.context?.epics || task?.metadata?.epics || [];
  const stories = task?.context?.user_stories || task?.metadata?.user_stories || [];
  const requirements = task?.metadata?.requirements || {};

  // Helper to format technical names to readable text
  const formatName = (name) => {
    return name
      .replace(/([A-Z])/g, ' $1')
      .replace(/View$|Display$|Screen$|Page$/i, '')
      .trim()
      .toLowerCase()
      .replace(/^./, c => c.toUpperCase());
  };

  let md = `# Project Proposal\n\n`;
  md += `## Overview\n\n${task?.description || 'No description provided.'}\n\n`;

  // Capabilities section - what the product does
  if (swimlanes.length > 0) {
    md += `## Product Capabilities\n\n`;
    swimlanes.forEach((sw, i) => {
      md += `### ${sw.name}\n\n`;
      if (sw.description) {
        md += `${sw.description}\n\n`;
      }

      if (sw.commands?.length > 0) {
        md += `**Users can:**\n`;
        sw.commands.forEach(cmd => {
          md += `- ${formatName(cmd)}\n`;
        });
        md += `\n`;
      }

      if (sw.read_models?.length > 0) {
        md += `**Users see:**\n`;
        sw.read_models.forEach(rm => {
          md += `- ${formatName(rm)}\n`;
        });
        md += `\n`;
      }

      if (sw.automations?.length > 0) {
        md += `**Automatic behaviors:**\n`;
        sw.automations.forEach(auto => {
          md += `- ${formatName(auto)}\n`;
        });
        md += `\n`;
      }
    });
  } else if (epics.length > 0) {
    // Fallback to epics if no swimlanes
    md += `## Features\n\n`;
    epics.forEach((epic, i) => {
      const epicTitle = epic.title || epic.name || 'Unnamed Feature';
      md += `### ${i + 1}. ${epicTitle}\n\n`;
      md += `${epic.description || ''}\n\n`;

      const epicStories = stories.filter((s) => s.epic_id === epic.id);
      if (epicStories.length > 0) {
        md += `**User Stories:**\n`;
        epicStories.forEach((story) => {
          const storyTitle = story.title || story.name ||
            (story.actor && story.action ? `As a ${story.actor}, ${story.action}` : 'Untitled');
          md += `- ${storyTitle}\n`;
        });
        md += `\n`;
      }
    });
  }

  // Requirements section if available
  const funcReqs = requirements.functional_requirements || [];
  const nonFuncReqs = requirements.non_functional_requirements || [];

  if (funcReqs.length > 0 || nonFuncReqs.length > 0) {
    md += `## Requirements\n\n`;

    if (funcReqs.length > 0) {
      md += `### Functional Requirements\n\n`;
      funcReqs.forEach(req => {
        md += `- **${req.id}** (${req.category}): ${req.requirement}\n`;
      });
      md += `\n`;
    }

    if (nonFuncReqs.length > 0) {
      md += `### Non-Functional Requirements\n\n`;
      nonFuncReqs.forEach(req => {
        md += `- **${req.id}** (${req.category}): ${req.requirement}\n`;
      });
      md += `\n`;
    }
  }

  md += `---\n*Generated by Cahoots*\n`;
  return md;
};

/**
 * Format for JIRA CSV export
 */
export const formatForJiraCSV = (task) => {
  const epics = task?.context?.epics || task?.metadata?.epics || [];
  const stories = task?.context?.user_stories || task?.metadata?.user_stories || [];

  const rows = [];
  rows.push(['Issue Type', 'Summary', 'Description', 'Epic Link', 'Story Points']);

  // Epics
  epics.forEach((epic) => {
    rows.push([
      'Epic',
      epic.title || epic.name || '',
      epic.description || '',
      '',
      '',
    ]);
  });

  // Stories
  stories.forEach((story) => {
    const summary = story.title || story.name ||
      (story.actor && story.action ? `As a ${story.actor}, ${story.action}` : '');
    const description = story.benefit ? `${summary} ${story.benefit}` : (story.description || '');

    rows.push([
      'Story',
      summary,
      description,
      story.epic_id || '',
      story.story_points || '',
    ]);
  });

  return rows.map(row =>
    row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(',')
  ).join('\n');
};

/**
 * Get persona-specific tabs
 */
export const getPersonaTabs = (persona) => {
  const tabs = {
    pm: [
      { id: 'overview', label: 'Overview', icon: 'ğŸ“Š' },
      { id: 'export', label: 'Export', icon: 'ğŸ“¤' },
    ],
    dev: [
      { id: 'eventmodel', label: 'Event Model', icon: 'ğŸ”„' },
      { id: 'scenarios', label: 'Scenarios', icon: 'ğŸ§ª' },
    ],
    consultant: [
      { id: 'scope', label: 'Scope', icon: 'ğŸ“' },
      { id: 'requirements', label: 'Requirements', icon: 'ğŸ“‹' },
      { id: 'proposal', label: 'Proposal', icon: 'ğŸ“„' },
    ],
  };

  return tabs[persona] || tabs.pm;
};
