/**
 * personaDataTransforms.js
 *
 * Utility functions to transform task data into persona-specific views.
 */

/**
 * Calculate story point metrics for PM view
 * Story points are on the tasks themselves (in the tree), not on story objects
 */
export const calculateStoryPointMetrics = (task, taskTree) => {
  const epics = task?.context?.epics || task?.metadata?.epics || [];
  const stories = task?.context?.user_stories || task?.metadata?.user_stories || [];

  // Sum story points from the task tree (tasks have story_points field)
  let totalPoints = 0;
  let atomicTasks = 0;

  const sumPoints = (node) => {
    if (!node) return;
    if (node.story_points) {
      totalPoints += node.story_points;
    }
    if (node.is_atomic) {
      atomicTasks++;
    }
    (node.children || []).forEach(sumPoints);
  };
  sumPoints(taskTree);

  return {
    totalPoints,
    epicCount: epics.length,
    storyCount: stories.length,
    atomicTasks,
  };
};

/**
 * Group stories by epic for PM overview
 * Stories have epic_id field (e.g., "EP-1"), epics have id field
 */
export const groupStoriesByEpic = (task) => {
  const epics = task?.context?.epics || task?.metadata?.epics || [];
  const stories = task?.context?.user_stories || task?.metadata?.user_stories || [];

  return epics.map((epic) => {
    const epicId = epic.id; // e.g., "EP-1"
    const epicStories = stories.filter((s) => s.epic_id === epicId);
    return {
      ...epic,
      name: epic.title || epic.name, // normalize to 'name' for display
      stories: epicStories,
    };
  });
};

/**
 * Extract event model components for Dev view
 */
export const extractEventModelComponents = (task) => {
  const metadata = task?.metadata || {};
  const events = metadata.extracted_events || [];
  const commands = metadata.commands || [];
  const readModels = metadata.read_models || [];
  const swimlanes = metadata.swimlanes || [];

  const normalizeItem = (item) => {
    if (typeof item === 'string') {
      return { name: item, description: '' };
    }
    return {
      name: item.name || item.title || 'Unknown',
      description: item.description || '',
      ...item,
    };
  };

  return {
    events: events.map(normalizeItem),
    commands: commands.map(normalizeItem),
    readModels: readModels.map(normalizeItem),
    swimlanes: swimlanes.map(normalizeItem),
    summary: {
      eventCount: events.length,
      commandCount: commands.length,
      readModelCount: readModels.length,
    },
  };
};

/**
 * Extract GWT scenarios for Dev view
 * Looks in multiple places:
 * 1. User stories with gwt_scenarios
 * 2. Acceptance criteria in GWT format
 * 3. Slices from chapters (generated by swimlane detector)
 */
export const extractGWTScenarios = (task) => {
  const scenarios = [];

  // Source 1: User stories with GWT scenarios
  const stories = task?.context?.user_stories || task?.metadata?.user_stories || [];
  stories.forEach((story) => {
    const storyTitle = story.title || story.name ||
      (story.actor && story.action ? `${story.actor} - ${story.action}` : 'Untitled Story');

    if (story.gwt_scenarios && Array.isArray(story.gwt_scenarios)) {
      story.gwt_scenarios.forEach((scenario) => {
        scenarios.push({
          storyTitle,
          given: scenario.given || '',
          when: scenario.when || '',
          then: scenario.then || '',
        });
      });
    }

    // Check acceptance_criteria for GWT format
    if (story.acceptance_criteria && Array.isArray(story.acceptance_criteria)) {
      story.acceptance_criteria.forEach((criteria) => {
        if (typeof criteria === 'object' && (criteria.given || criteria.when || criteria.then)) {
          scenarios.push({
            storyTitle,
            given: criteria.given || '',
            when: criteria.when || '',
            then: criteria.then || '',
          });
        }
      });
    }
  });

  // Source 2: Slices from chapters (swimlane detector generates these)
  const chapters = task?.metadata?.chapters || [];
  chapters.forEach((chapter) => {
    const slices = chapter?.slices || [];
    slices.forEach((slice) => {
      if (slice.gwt_scenarios && Array.isArray(slice.gwt_scenarios)) {
        const sliceName = slice.command || slice.read_model || slice.automation_name || 'Unknown Slice';
        slice.gwt_scenarios.forEach((scenario) => {
          scenarios.push({
            storyTitle: sliceName,
            given: scenario.given || '',
            when: scenario.when || '',
            then: scenario.then || '',
          });
        });
      }
    });
  });

  return scenarios;
};

/**
 * Transform technical event names into business-friendly capability names
 * "EmailVerificationSent" â†’ "Email verification"
 * "UserRegistered" â†’ "User registration"
 * "RecipeCreated" â†’ "Recipe creation"
 */
const toBusinessCapability = (technicalName) => {
  if (!technicalName) return '';

  // Split camelCase/PascalCase into words
  let words = technicalName
    .replace(/([A-Z])/g, ' $1')
    .trim()
    .split(/\s+/);

  // Remove common technical suffixes that don't add business value
  const technicalSuffixes = [
    'Event', 'Command', 'Handler', 'Service', 'Repository',
    'Created', 'Updated', 'Deleted', 'Sent', 'Received',
    'Started', 'Completed', 'Failed', 'Processed', 'View',
    'Display', 'Screen', 'Page', 'Model', 'Query'
  ];

  // Convert past tense verbs to noun form for better readability
  const pastToNoun = {
    'registered': 'registration',
    'created': 'creation',
    'updated': 'updates',
    'deleted': 'deletion',
    'sent': 'sending',
    'received': 'receipt',
    'verified': 'verification',
    'authenticated': 'authentication',
    'processed': 'processing',
    'completed': 'completion',
    'failed': 'failure',
    'added': 'addition',
    'removed': 'removal',
    'changed': 'changes',
    'modified': 'modifications',
    'saved': 'saving',
    'loaded': 'loading',
    'fetched': 'fetching',
    'submitted': 'submission',
    'cancelled': 'cancellation',
    'approved': 'approval',
    'rejected': 'rejection',
    'published': 'publishing',
    'archived': 'archiving',
  };

  // Remove technical suffixes and convert
  words = words.filter(w => !technicalSuffixes.includes(w));

  // Convert last word if it's a past tense verb
  if (words.length > 0) {
    const lastWord = words[words.length - 1].toLowerCase();
    if (pastToNoun[lastWord]) {
      words[words.length - 1] = pastToNoun[lastWord];
    }
  }

  // Join and format nicely
  return words.join(' ').toLowerCase().replace(/^\w/, c => c.toUpperCase());
};

/**
 * Infer automatic behaviors from event chains and automations
 * E.g., BidAccepted -> EscrowFundsHeld suggests automatic escrow on bid acceptance
 */
const inferAutomaticBehaviors = (task) => {
  const metadata = task?.metadata || {};
  const automations = metadata.automations || [];
  const commands = metadata.commands || [];
  const events = metadata.extracted_events || [];

  const behaviors = [];

  // Extract from explicit automations
  automations.forEach(auto => {
    const name = typeof auto === 'string' ? auto : auto.name;
    const desc = typeof auto === 'object' ? auto.description : '';
    if (name) {
      behaviors.push({
        name: toBusinessCapability(name),
        description: desc,
        type: 'automation'
      });
    }
  });

  // Infer from command -> event chains
  commands.forEach(cmd => {
    const cmdName = typeof cmd === 'string' ? cmd : cmd.name;
    const triggers = cmd.triggers_events || [];

    // Look for patterns indicating automatic behavior
    triggers.forEach(evt => {
      const evtLower = evt.toLowerCase();
      // If a command triggers multiple events, some may be automatic side-effects
      if (triggers.length > 1 &&
          (evtLower.includes('sent') || evtLower.includes('notification') ||
           evtLower.includes('email') || evtLower.includes('created') ||
           evtLower.includes('initialized') || evtLower.includes('updated'))) {
        // E.g., RegisterUser -> VerificationEmailSent
        const behavior = toBusinessCapability(evt);
        if (behavior && !behaviors.find(b => b.name === behavior)) {
          behaviors.push({
            name: behavior,
            description: `Triggered automatically when ${toBusinessCapability(cmdName)}`,
            type: 'side_effect'
          });
        }
      }
    });
  });

  // Look for common automation patterns in events
  const automationPatterns = [
    { pattern: /EmailSent|NotificationSent|AlertSent/i, desc: 'notification sent automatically' },
    { pattern: /AccountLocked|RateLimited/i, desc: 'triggered by security rules' },
    { pattern: /FundsHeld|EscrowCreated|PaymentProcessed/i, desc: 'triggered by transaction' },
    { pattern: /TokenExpired|SessionEnded/i, desc: 'triggered by time expiry' },
    { pattern: /BadgeAwarded|PointsAwarded/i, desc: 'triggered by achievement' },
  ];

  events.forEach(evt => {
    const evtName = typeof evt === 'string' ? evt : evt.name;
    automationPatterns.forEach(({ pattern, desc }) => {
      if (pattern.test(evtName)) {
        const behavior = toBusinessCapability(evtName);
        if (behavior && !behaviors.find(b => b.name === behavior)) {
          behaviors.push({
            name: behavior,
            description: desc,
            type: 'inferred'
          });
        }
      }
    });
  });

  return behaviors;
};

/**
 * Extract actor/persona from user story
 */
const extractPersona = (story) => {
  const actor = story?.actor || '';
  const actorLower = actor.toLowerCase();

  if (actorLower.includes('admin') || actorLower.includes('moderator') || actorLower.includes('operator')) {
    return 'admin';
  }
  if (actorLower.includes('client') || actorLower.includes('buyer') || actorLower.includes('customer')) {
    return 'client';
  }
  if (actorLower.includes('freelancer') || actorLower.includes('seller') || actorLower.includes('provider') ||
      actorLower.includes('vendor') || actorLower.includes('tutor') || actorLower.includes('teacher')) {
    return 'provider';
  }
  if (actorLower.includes('system') || actorLower.includes('platform')) {
    return 'system';
  }
  return 'user'; // Default persona
};

/**
 * Aggregate event model data by business domain for consultant view
 * Uses epics as primary source (clean, business-focused) and enriches with commands/read models
 */
export const aggregateByBusinessDomain = (task) => {
  const context = task?.context || {};
  const metadata = task?.metadata || {};

  // Primary source: Epics (clean business-focused domains)
  const epics = context.epics || metadata.epics || [];
  const stories = context.user_stories || metadata.user_stories || [];

  // Secondary sources: Event model elements
  const readModels = metadata.read_models || [];
  const chapters = metadata.chapters || [];

  // Build domain map from epics
  const domains = new Map();

  // Helper to clean and normalize domain names
  const cleanDomainName = (name) => {
    if (!name) return 'General';
    // Remove numbers, newlines, and normalize spacing
    return name
      .replace(/\n\d+/g, '')  // Remove \n followed by numbers
      .replace(/\d+\s*$/g, '') // Remove trailing numbers
      .replace(/\n/g, ' ')     // Replace newlines with spaces
      .replace(/\s+/g, ' ')    // Normalize whitespace
      .trim()
      .split(/(?=[A-Z])/).join(' ') // Split PascalCase
      .replace(/\s+/g, ' ')
      .trim();
  };

  const ensureDomain = (domainName, description = '') => {
    const cleanName = cleanDomainName(domainName);
    if (!domains.has(cleanName)) {
      domains.set(cleanName, {
        name: cleanName,
        description: description,
        clientActions: new Set(),
        providerActions: new Set(),
        adminActions: new Set(),
        userActions: new Set(),
        systemActions: new Set(),
        views: new Set(),
        automations: new Set(),
      });
    } else if (description && !domains.get(cleanName).description) {
      domains.get(cleanName).description = description;
    }
    return domains.get(cleanName);
  };

  // Step 1: Create domains from epics (best source)
  epics.forEach(epic => {
    const epicTitle = epic.title || epic.name || 'General';
    const domain = ensureDomain(epicTitle, epic.description);

    // Get stories for this epic
    const epicStories = stories.filter(s => s.epic_id === epic.id);

    epicStories.forEach(story => {
      const persona = extractPersona(story);
      const action = story.action || story.title || '';

      if (action) {
        // Clean the action text for display
        const cleanAction = action
          .replace(/^(I want to |I can |I should be able to )/i, '')
          .replace(/^\w/, c => c.toUpperCase());

        // Add to appropriate persona bucket
        switch (persona) {
          case 'client':
            domain.clientActions.add(cleanAction);
            break;
          case 'provider':
            domain.providerActions.add(cleanAction);
            break;
          case 'admin':
            domain.adminActions.add(cleanAction);
            break;
          case 'system':
            domain.systemActions.add(cleanAction);
            break;
          default:
            domain.userActions.add(cleanAction);
        }
      }
    });
  });

  // Step 2: Extract read models from chapters (cleaner than swimlanes)
  const readModelsByDomain = new Map();
  chapters.forEach(chapter => {
    // Parse chapter name to extract domain
    const chapterName = chapter.name || '';
    const domainPart = chapterName.split(':')[0] || '';
    const cleanDomain = cleanDomainName(domainPart);

    (chapter.slices || []).forEach(slice => {
      if (slice.read_model) {
        if (!readModelsByDomain.has(cleanDomain)) {
          readModelsByDomain.set(cleanDomain, new Set());
        }
        readModelsByDomain.set(cleanDomain,
          readModelsByDomain.get(cleanDomain).add(toBusinessCapability(slice.read_model)));
      }
    });
  });

  // Match read models to domains
  readModelsByDomain.forEach((readModels, chapterDomain) => {
    // Find best matching epic domain
    let bestMatch = null;
    let bestScore = 0;

    domains.forEach((domain, domainName) => {
      const score = calculateSimilarity(chapterDomain, domainName);
      if (score > bestScore) {
        bestScore = score;
        bestMatch = domainName;
      }
    });

    if (bestMatch && bestScore > 0.3) {
      readModels.forEach(rm => domains.get(bestMatch).views.add(rm));
    }
  });

  // Step 3: Add read models from event model
  readModels.forEach(rm => {
    const rmName = typeof rm === 'string' ? rm : rm.name;
    if (!rmName) return;

    // Try to match to a domain
    let bestMatch = null;
    let bestScore = 0;

    domains.forEach((domain, domainName) => {
      const score = calculateSimilarity(rmName, domainName);
      if (score > bestScore) {
        bestScore = score;
        bestMatch = domainName;
      }
    });

    if (bestMatch && bestScore > 0.2) {
      domains.get(bestMatch).views.add(toBusinessCapability(rmName));
    }
  });

  // Step 4: Add automatic behaviors
  const automaticBehaviors = inferAutomaticBehaviors(task);

  // Try to assign automations to domains
  automaticBehaviors.forEach(behavior => {
    let assigned = false;

    // Try to match to a domain by keyword
    domains.forEach((domain, domainName) => {
      const domainLower = domainName.toLowerCase();
      const behaviorLower = behavior.name.toLowerCase();

      if (behaviorLower.includes(domainLower.split(' ')[0]) ||
          domainLower.includes(behaviorLower.split(' ')[0])) {
        domain.automations.add(behavior.name);
        assigned = true;
      }
    });

    // If not assigned, put in most relevant domain based on keywords
    if (!assigned) {
      const behaviorLower = behavior.name.toLowerCase();
      if (behaviorLower.includes('email') || behaviorLower.includes('notification')) {
        const notifDomain = Array.from(domains.keys()).find(d =>
          d.toLowerCase().includes('notification') || d.toLowerCase().includes('communication'));
        if (notifDomain) {
          domains.get(notifDomain).automations.add(behavior.name);
        }
      } else if (behaviorLower.includes('escrow') || behaviorLower.includes('fund') || behaviorLower.includes('payment')) {
        const paymentDomain = Array.from(domains.keys()).find(d =>
          d.toLowerCase().includes('escrow') || d.toLowerCase().includes('payment') || d.toLowerCase().includes('milestone'));
        if (paymentDomain) {
          domains.get(paymentDomain).automations.add(behavior.name);
        }
      }
    }
  });

  // Convert Map to array with structured output
  return Array.from(domains.values())
    .map(domain => ({
      name: domain.name,
      description: domain.description,
      clientActions: Array.from(domain.clientActions),
      providerActions: Array.from(domain.providerActions),
      adminActions: Array.from(domain.adminActions),
      userActions: Array.from(domain.userActions),
      systemActions: Array.from(domain.systemActions),
      views: Array.from(domain.views),
      automations: Array.from(domain.automations),
      // Legacy fields for backward compatibility
      actions: [
        ...Array.from(domain.clientActions),
        ...Array.from(domain.providerActions),
        ...Array.from(domain.adminActions),
        ...Array.from(domain.userActions),
      ],
      capabilities: [],
    }))
    .filter(d =>
      // Filter out empty domains
      d.clientActions.length > 0 || d.providerActions.length > 0 ||
      d.adminActions.length > 0 || d.userActions.length > 0 ||
      d.views.length > 0 || d.automations.length > 0
    )
    .sort((a, b) => {
      // Sort by priority: User/Profile first, then core business, then support functions
      const priority = {
        'User Management': 1,
        'User': 1,
        'Profile': 2,
        'Marketplace': 3,
        'Project': 3,
        'Escrow': 4,
        'Payment': 4,
        'Milestone': 4,
        'Dispute': 5,
        'Trust': 5,
        'Notification': 6,
        'Communication': 6,
        'Admin': 7,
        'Reporting': 7,
      };

      const getPriority = (name) => {
        for (const [key, val] of Object.entries(priority)) {
          if (name.toLowerCase().includes(key.toLowerCase())) return val;
        }
        return 5;
      };

      return getPriority(a.name) - getPriority(b.name);
    });
};

/**
 * Calculate simple string similarity (0-1)
 */
const calculateSimilarity = (str1, str2) => {
  if (!str1 || !str2) return 0;

  const s1 = str1.toLowerCase().replace(/[^a-z]/g, '');
  const s2 = str2.toLowerCase().replace(/[^a-z]/g, '');

  if (s1 === s2) return 1;
  if (s1.includes(s2) || s2.includes(s1)) return 0.8;

  // Check word overlap
  const words1 = new Set(str1.toLowerCase().split(/\W+/).filter(w => w.length > 2));
  const words2 = new Set(str2.toLowerCase().split(/\W+/).filter(w => w.length > 2));

  let overlap = 0;
  words1.forEach(w => { if (words2.has(w)) overlap++; });

  return overlap / Math.max(words1.size, words2.size, 1);
};

/**
 * Generate executive summary for consultant proposals
 */
export const generateExecutiveSummary = (task, taskTree) => {
  const domains = aggregateByBusinessDomain(task);
  const metrics = calculateScopeMetrics(task, taskTree);

  // Build a high-level summary
  const domainNames = domains.map(d => d.name).slice(0, 5);
  const totalCapabilities = domains.reduce((sum, d) =>
    sum + d.actions.length + d.views.length + d.automations.length, 0
  );

  let summary = `This project delivers a comprehensive solution spanning ${domains.length} core business areas`;

  if (domainNames.length > 0) {
    summary += ` including ${domainNames.slice(0, 3).join(', ')}`;
    if (domainNames.length > 3) {
      summary += `, and ${domainNames.length - 3} more`;
    }
  }

  summary += `. The system provides ${totalCapabilities} distinct capabilities`;

  if (metrics.storyCount > 0) {
    summary += ` across ${metrics.storyCount} user stories`;
  }

  summary += '.';

  return summary;
};

/**
 * Calculate scope metrics for Consultant view
 */
export const calculateScopeMetrics = (task, taskTree) => {
  const epics = task?.context?.epics || task?.metadata?.epics || [];
  const stories = task?.context?.user_stories || task?.metadata?.user_stories || [];
  const metadata = task?.metadata || {};
  const events = metadata.extracted_events || [];
  const commands = metadata.commands || [];

  let totalTasks = 0;
  const countTasks = (node) => {
    if (!node) return;
    totalTasks++;
    (node.children || []).forEach(countTasks);
  };
  countTasks(taskTree);

  // Simple complexity rating
  const featureCount = epics.length + stories.length;
  let complexityRating = 'Small';
  if (featureCount > 30) complexityRating = 'Large';
  else if (featureCount > 15) complexityRating = 'Medium';

  return {
    epicCount: epics.length,
    storyCount: stories.length,
    totalTasks,
    complexityRating,
    eventCount: events.length,
    commandCount: commands.length,
  };
};

/**
 * Generate proposal markdown for Consultant export
 * Uses business-friendly domain aggregation instead of raw technical data
 */
export const generateProposalMarkdown = (task, taskTree) => {
  const businessDomains = aggregateByBusinessDomain(task);
  const epics = task?.context?.epics || task?.metadata?.epics || [];
  const stories = task?.context?.user_stories || task?.metadata?.user_stories || [];
  const requirements = task?.metadata?.requirements || {};
  const execSummary = generateExecutiveSummary(task, taskTree);

  let md = `# Project Proposal\n\n`;

  // Executive Summary section
  md += `## Executive Summary\n\n`;
  md += `${task?.description || 'No description provided.'}\n\n`;
  md += `${execSummary}\n\n`;

  // Business Capabilities section - aggregated by domain
  if (businessDomains.length > 0) {
    md += `## Business Capabilities\n\n`;
    businessDomains.forEach((domain) => {
      md += `### ${domain.name}\n\n`;
      if (domain.description) {
        md += `${domain.description}\n\n`;
      }

      if (domain.actions.length > 0) {
        md += `**What users can do:**\n`;
        domain.actions.forEach(action => {
          md += `- ${action}\n`;
        });
        md += `\n`;
      }

      if (domain.views.length > 0) {
        md += `**What users see:**\n`;
        domain.views.forEach(view => {
          md += `- ${view}\n`;
        });
        md += `\n`;
      }

      if (domain.automations.length > 0) {
        md += `**Automatic behaviors:**\n`;
        domain.automations.forEach(auto => {
          md += `- ${auto}\n`;
        });
        md += `\n`;
      }

      // For domains built from raw events (no swimlanes)
      if (domain.capabilities.length > 0 && domain.actions.length === 0) {
        md += `**Key capabilities:**\n`;
        domain.capabilities.forEach(cap => {
          md += `- ${cap}\n`;
        });
        md += `\n`;
      }
    });
  } else if (epics.length > 0) {
    // Fallback to epics if no event model data
    md += `## Features\n\n`;
    epics.forEach((epic, i) => {
      const epicTitle = epic.title || epic.name || 'Unnamed Feature';
      md += `### ${i + 1}. ${epicTitle}\n\n`;
      md += `${epic.description || ''}\n\n`;

      const epicStories = stories.filter((s) => s.epic_id === epic.id);
      if (epicStories.length > 0) {
        md += `**User Stories:**\n`;
        epicStories.forEach((story) => {
          const storyTitle = story.title || story.name ||
            (story.actor && story.action ? `As a ${story.actor}, ${story.action}` : 'Untitled');
          md += `- ${storyTitle}\n`;
        });
        md += `\n`;
      }
    });
  }

  // Requirements section if available
  const funcReqs = requirements.functional_requirements || [];
  const nonFuncReqs = requirements.non_functional_requirements || [];

  if (funcReqs.length > 0 || nonFuncReqs.length > 0) {
    md += `## Requirements\n\n`;

    if (funcReqs.length > 0) {
      md += `### Functional Requirements\n\n`;
      funcReqs.forEach(req => {
        md += `- **${req.id}** (${req.category}): ${req.requirement}\n`;
      });
      md += `\n`;
    }

    if (nonFuncReqs.length > 0) {
      md += `### Non-Functional Requirements\n\n`;
      nonFuncReqs.forEach(req => {
        md += `- **${req.id}** (${req.category}): ${req.requirement}\n`;
      });
      md += `\n`;
    }
  }

  md += `---\n*Generated by Cahoots*\n`;
  return md;
};

/**
 * Format for JIRA CSV export
 */
export const formatForJiraCSV = (task) => {
  const epics = task?.context?.epics || task?.metadata?.epics || [];
  const stories = task?.context?.user_stories || task?.metadata?.user_stories || [];

  const rows = [];
  rows.push(['Issue Type', 'Summary', 'Description', 'Epic Link', 'Story Points']);

  // Epics
  epics.forEach((epic) => {
    rows.push([
      'Epic',
      epic.title || epic.name || '',
      epic.description || '',
      '',
      '',
    ]);
  });

  // Stories
  stories.forEach((story) => {
    const summary = story.title || story.name ||
      (story.actor && story.action ? `As a ${story.actor}, ${story.action}` : '');
    const description = story.benefit ? `${summary} ${story.benefit}` : (story.description || '');

    rows.push([
      'Story',
      summary,
      description,
      story.epic_id || '',
      story.story_points || '',
    ]);
  });

  return rows.map(row =>
    row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(',')
  ).join('\n');
};

/**
 * Get persona-specific tabs
 */
export const getPersonaTabs = (persona) => {
  const tabs = {
    pm: [
      { id: 'overview', label: 'Overview', icon: 'ğŸ“Š' },
      { id: 'tasks', label: 'Tasks', icon: 'âœ…' },
      { id: 'export', label: 'Export', icon: 'ğŸ“¤' },
    ],
    dev: [
      { id: 'eventmodel', label: 'Event Model', icon: 'ğŸ”„' },
      { id: 'scenarios', label: 'Scenarios', icon: 'ğŸ§ª' },
      { id: 'codegen', label: 'Code Gen', icon: 'âš¡' },
    ],
    consultant: [
      { id: 'scope', label: 'Scope', icon: 'ğŸ“' },
      { id: 'requirements', label: 'Requirements', icon: 'ğŸ“‹' },
      { id: 'proposal', label: 'Proposal', icon: 'ğŸ“„' },
    ],
  };

  return tabs[persona] || tabs.pm;
};
