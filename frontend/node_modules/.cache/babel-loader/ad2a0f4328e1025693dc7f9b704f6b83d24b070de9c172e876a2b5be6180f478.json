{"ast":null,"code":"import{useState,useEffect,useCallback,useRef}from'react';// WebSocket connection states\nexport const WS_STATES={DISCONNECTED:'disconnected',CONNECTING:'connecting',CONNECTED:'connected'};/**\n * Custom hook for managing WebSocket connections\n * @param {string|Function} urlOrGetter - Base URL or function that returns URL for WebSocket connection\n * @param {Function} onMessage - Callback for handling incoming messages\n * @returns {Object} WebSocket connection utilities\n */const useWebSocket=(urlOrGetter,onMessage)=>{const[wsState,setWsState]=useState(WS_STATES.DISCONNECTED);const wsStateRef=useRef(WS_STATES.DISCONNECTED);// WebSocket connection management refs\nconst socketRef=useRef(null);const taskIdRef=useRef(null);const connectionTimerRef=useRef(null);const reconnectTimerRef=useRef(null);const onMessageRef=useRef(onMessage);const lastConnectionAttemptRef=useRef(0);// Update message handler ref when it changes\nuseEffect(()=>{onMessageRef.current=onMessage;},[onMessage]);// Update both state and ref when state changes\nconst updateWsState=useCallback(newState=>{setWsState(newState);wsStateRef.current=newState;},[]);// Clean up any existing connection timers\nconst cleanupConnectionTimers=useCallback(()=>{// Clear any pending connection timers\nif(connectionTimerRef.current){clearTimeout(connectionTimerRef.current);connectionTimerRef.current=null;}// Clear any pending reconnection timers\nif(reconnectTimerRef.current){clearTimeout(reconnectTimerRef.current);reconnectTimerRef.current=null;}},[]);// Safely clean up a WebSocket instance\nconst cleanupWebSocket=useCallback(ws=>{if(!ws)return;try{// Clear all intervals\nif(ws.heartbeatInterval){clearInterval(ws.heartbeatInterval);ws.heartbeatInterval=null;}if(ws.monitorInterval){clearInterval(ws.monitorInterval);ws.monitorInterval=null;}// Close the connection if it's still open\nif(ws.readyState===WebSocket.OPEN){// Close the socket\ntry{ws.close();}catch(e){// Ignore errors during close\n}}}catch(err){console.error('Error cleaning up WebSocket:',err);}},[]);// Disconnect WebSocket\nconst disconnect=useCallback(()=>{// If already disconnected, do nothing\nif(wsStateRef.current===WS_STATES.DISCONNECTED&&!socketRef.current){return;}console.log(`Disconnecting WebSocket for task ${taskIdRef.current}`);// Clean up any existing timers\ncleanupConnectionTimers();// Get the current socket\nconst ws=socketRef.current;if(!ws){// No socket, so just reset state\nupdateWsState(WS_STATES.DISCONNECTED);taskIdRef.current=null;return;}try{// Clean up the WebSocket\ncleanupWebSocket(ws);// Reset state immediately\nsocketRef.current=null;updateWsState(WS_STATES.DISCONNECTED);// Don't clear taskIdRef here - let the caller decide\n}catch(err){console.error('Error disconnecting WebSocket:',err);// Force reset even on error\nsocketRef.current=null;updateWsState(WS_STATES.DISCONNECTED);}},[cleanupConnectionTimers,cleanupWebSocket,updateWsState]);// Set up WebSocket event handlers\nconst setupWebSocketHandlers=useCallback((ws,taskId)=>{if(!ws)return;// Set up event handlers\nws.onopen=()=>{console.log(`WebSocket connection opened for task ${taskId}`);updateWsState(WS_STATES.CONNECTED);// Set up heartbeat interval\nws.heartbeatInterval=setInterval(()=>{if(ws.readyState===WebSocket.OPEN){try{ws.send(JSON.stringify({type:'heartbeat'}));}catch(e){console.error('Error sending heartbeat:',e);}}},30000);// 30 seconds - less frequent heartbeats\n// Set up connection monitor\nws.monitorInterval=setInterval(()=>{if(ws.readyState!==WebSocket.OPEN){console.warn('WebSocket connection lost, clearing intervals');clearInterval(ws.heartbeatInterval);clearInterval(ws.monitorInterval);// Try to reconnect\nif(wsStateRef.current!==WS_STATES.DISCONNECTED){console.log('Attempting to reconnect...');updateWsState(WS_STATES.DISCONNECTED);// Reconnect immediately\nif(taskIdRef.current){console.log(`Reconnecting to WebSocket for task: ${taskIdRef.current}`);initializeWebSocket(taskIdRef.current);}}}},3000);// 3 seconds - check connection more frequently\n};ws.onclose=()=>{console.log(`WebSocket connection closed for task ${taskId}`);if(wsStateRef.current!==WS_STATES.DISCONNECTED){updateWsState(WS_STATES.DISCONNECTED);// Try to reconnect after a delay\nreconnectTimerRef.current=setTimeout(()=>{if(wsStateRef.current===WS_STATES.DISCONNECTED&&taskIdRef.current){console.log(`Attempting to reconnect to WebSocket for task: ${taskIdRef.current}`);initializeWebSocket(taskIdRef.current);}},5000);}};ws.onerror=error=>{console.error(`WebSocket error for task ${taskId}:`,error);if(wsStateRef.current!==WS_STATES.DISCONNECTED){updateWsState(WS_STATES.DISCONNECTED);// Try to reconnect after a delay\nreconnectTimerRef.current=setTimeout(()=>{if(wsStateRef.current===WS_STATES.DISCONNECTED&&taskIdRef.current){console.log(`Attempting to reconnect after error for task: ${taskIdRef.current}`);initializeWebSocket(taskIdRef.current);}},5000);}};ws.onmessage=event=>{try{const data=JSON.parse(event.data);console.log(`WebSocket message received for task ${taskId}:`,data);// Call the provided message handler for all messages\nif(onMessageRef.current){onMessageRef.current(data);}}catch(err){console.error('Error processing WebSocket message:',err);}};},[updateWsState]);// Initialize WebSocket connection with retry logic\nconst initializeWebSocket=useCallback(taskId=>{try{// Only start if we're disconnected\nif(wsStateRef.current!==WS_STATES.DISCONNECTED){return;}// Rate limiting: prevent too many rapid connection attempts\nconst now=Date.now();if(now-lastConnectionAttemptRef.current<1000){console.log('Rate limiting: Too many connection attempts, waiting...');return;}lastConnectionAttemptRef.current=now;updateWsState(WS_STATES.CONNECTING);// Get the WebSocket URL\nlet wsUrl;if(typeof urlOrGetter==='function'){wsUrl=urlOrGetter(taskId);}else{// For backward compatibility\nwsUrl=taskId?`${urlOrGetter}/${taskId}`:urlOrGetter;}if(!wsUrl){console.warn('No WebSocket URL available');updateWsState(WS_STATES.DISCONNECTED);return;}console.log(`Connecting to WebSocket URL: ${wsUrl}`);// Store the task ID for reconnection\ntaskIdRef.current=taskId;const ws=new WebSocket(wsUrl);socketRef.current=ws;// Set up all event handlers\nsetupWebSocketHandlers(ws,taskId);}catch(error){console.error('WebSocket connection error:',error);updateWsState(WS_STATES.DISCONNECTED);// Try to reconnect after a delay\nreconnectTimerRef.current=setTimeout(()=>{if(wsStateRef.current===WS_STATES.DISCONNECTED&&taskIdRef.current){initializeWebSocket(taskIdRef.current);}},5000);}},[urlOrGetter,updateWsState,setupWebSocketHandlers]);// Connect to WebSocket\nconst connect=useCallback(taskId=>{// Don't attempt to connect if taskId is null, undefined, or not a valid UUID\nif(!taskId||!/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(taskId)){console.warn('Not connecting WebSocket: Invalid or missing task ID');disconnect();return;}// If already connected to this task, do nothing\nif(socketRef.current&&wsStateRef.current===WS_STATES.CONNECTED&&taskIdRef.current===taskId){console.log(`Already connected to task ${taskId}, skipping connection`);return;}// If we're already trying to connect to this task, wait\nif(wsStateRef.current===WS_STATES.CONNECTING&&taskIdRef.current===taskId){console.log(`Already connecting to task ${taskId}, waiting...`);return;}// Store the task ID\ntaskIdRef.current=taskId;// Clean up any existing connection and wait for it to close\nif(socketRef.current){console.log(`Switching from ${taskIdRef.current} to ${taskId}, cleaning up old connection`);disconnect();// Wait a bit before creating new connection to ensure cleanup is complete\nsetTimeout(()=>{if(taskIdRef.current===taskId){initializeWebSocket(taskId);}},100);}else{// No existing connection, initialize immediately\ninitializeWebSocket(taskId);}},[disconnect,initializeWebSocket]);// Clean up on unmount\nuseEffect(()=>{return()=>{disconnect();};},[disconnect]);return{wsState,connect,disconnect,isConnected:wsState===WS_STATES.CONNECTED,currentTaskId:taskIdRef.current};};export default useWebSocket;","map":{"version":3,"names":["useState","useEffect","useCallback","useRef","WS_STATES","DISCONNECTED","CONNECTING","CONNECTED","useWebSocket","urlOrGetter","onMessage","wsState","setWsState","wsStateRef","socketRef","taskIdRef","connectionTimerRef","reconnectTimerRef","onMessageRef","lastConnectionAttemptRef","current","updateWsState","newState","cleanupConnectionTimers","clearTimeout","cleanupWebSocket","ws","heartbeatInterval","clearInterval","monitorInterval","readyState","WebSocket","OPEN","close","e","err","console","error","disconnect","log","setupWebSocketHandlers","taskId","onopen","setInterval","send","JSON","stringify","type","warn","initializeWebSocket","onclose","setTimeout","onerror","onmessage","event","data","parse","now","Date","wsUrl","connect","test","isConnected","currentTaskId"],"sources":["/app/src/hooks/useWebSocket.js"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react';\n\n// WebSocket connection states\nexport const WS_STATES = {\n  DISCONNECTED: 'disconnected',\n  CONNECTING: 'connecting',\n  CONNECTED: 'connected'\n};\n\n/**\n * Custom hook for managing WebSocket connections\n * @param {string|Function} urlOrGetter - Base URL or function that returns URL for WebSocket connection\n * @param {Function} onMessage - Callback for handling incoming messages\n * @returns {Object} WebSocket connection utilities\n */\nconst useWebSocket = (urlOrGetter, onMessage) => {\n  const [wsState, setWsState] = useState(WS_STATES.DISCONNECTED);\n  const wsStateRef = useRef(WS_STATES.DISCONNECTED);\n  \n  // WebSocket connection management refs\n  const socketRef = useRef(null);\n  const taskIdRef = useRef(null);\n  const connectionTimerRef = useRef(null);\n  const reconnectTimerRef = useRef(null);\n  const onMessageRef = useRef(onMessage);\n  const lastConnectionAttemptRef = useRef(0);\n\n  // Update message handler ref when it changes\n  useEffect(() => {\n    onMessageRef.current = onMessage;\n  }, [onMessage]);\n\n  // Update both state and ref when state changes\n  const updateWsState = useCallback((newState) => {\n    setWsState(newState);\n    wsStateRef.current = newState;\n  }, []);\n\n  // Clean up any existing connection timers\n  const cleanupConnectionTimers = useCallback(() => {\n    // Clear any pending connection timers\n    if (connectionTimerRef.current) {\n      clearTimeout(connectionTimerRef.current);\n      connectionTimerRef.current = null;\n    }\n    \n    // Clear any pending reconnection timers\n    if (reconnectTimerRef.current) {\n      clearTimeout(reconnectTimerRef.current);\n      reconnectTimerRef.current = null;\n    }\n  }, []);\n\n  // Safely clean up a WebSocket instance\n  const cleanupWebSocket = useCallback((ws) => {\n    if (!ws) return;\n    \n    try {\n      // Clear all intervals\n      if (ws.heartbeatInterval) {\n        clearInterval(ws.heartbeatInterval);\n        ws.heartbeatInterval = null;\n      }\n      if (ws.monitorInterval) {\n        clearInterval(ws.monitorInterval);\n        ws.monitorInterval = null;\n      }\n      \n      // Close the connection if it's still open\n      if (ws.readyState === WebSocket.OPEN) {\n        // Close the socket\n        try {\n          ws.close();\n        } catch (e) {\n          // Ignore errors during close\n        }\n      }\n    } catch (err) {\n      console.error('Error cleaning up WebSocket:', err);\n    }\n  }, []);\n\n  // Disconnect WebSocket\n  const disconnect = useCallback(() => {\n    // If already disconnected, do nothing\n    if (wsStateRef.current === WS_STATES.DISCONNECTED && !socketRef.current) {\n      return;\n    }\n    \n    console.log(`Disconnecting WebSocket for task ${taskIdRef.current}`);\n    \n    // Clean up any existing timers\n    cleanupConnectionTimers();\n    \n    // Get the current socket\n    const ws = socketRef.current;\n    if (!ws) {\n      // No socket, so just reset state\n      updateWsState(WS_STATES.DISCONNECTED);\n      taskIdRef.current = null;\n      return;\n    }\n    \n    try {\n      // Clean up the WebSocket\n      cleanupWebSocket(ws);\n      \n      // Reset state immediately\n      socketRef.current = null;\n      updateWsState(WS_STATES.DISCONNECTED);\n      // Don't clear taskIdRef here - let the caller decide\n    } catch (err) {\n      console.error('Error disconnecting WebSocket:', err);\n      // Force reset even on error\n      socketRef.current = null;\n      updateWsState(WS_STATES.DISCONNECTED);\n    }\n  }, [cleanupConnectionTimers, cleanupWebSocket, updateWsState]);\n\n  // Set up WebSocket event handlers\n  const setupWebSocketHandlers = useCallback((ws, taskId) => {\n    if (!ws) return;\n    \n    // Set up event handlers\n    ws.onopen = () => {\n      console.log(`WebSocket connection opened for task ${taskId}`);\n      updateWsState(WS_STATES.CONNECTED);\n      \n      // Set up heartbeat interval\n      ws.heartbeatInterval = setInterval(() => {\n        if (ws.readyState === WebSocket.OPEN) {\n          try {\n            ws.send(JSON.stringify({ type: 'heartbeat' }));\n          } catch (e) {\n            console.error('Error sending heartbeat:', e);\n          }\n        }\n      }, 30000); // 30 seconds - less frequent heartbeats\n      \n      // Set up connection monitor\n      ws.monitorInterval = setInterval(() => {\n        if (ws.readyState !== WebSocket.OPEN) {\n          console.warn('WebSocket connection lost, clearing intervals');\n          clearInterval(ws.heartbeatInterval);\n          clearInterval(ws.monitorInterval);\n          \n          // Try to reconnect\n          if (wsStateRef.current !== WS_STATES.DISCONNECTED) {\n            console.log('Attempting to reconnect...');\n            updateWsState(WS_STATES.DISCONNECTED);\n            \n            // Reconnect immediately\n            if (taskIdRef.current) {\n              console.log(`Reconnecting to WebSocket for task: ${taskIdRef.current}`);\n              initializeWebSocket(taskIdRef.current);\n            }\n          }\n        }\n      }, 3000); // 3 seconds - check connection more frequently\n    };\n    \n    ws.onclose = () => {\n      console.log(`WebSocket connection closed for task ${taskId}`);\n      if (wsStateRef.current !== WS_STATES.DISCONNECTED) {\n        updateWsState(WS_STATES.DISCONNECTED);\n        \n        // Try to reconnect after a delay\n        reconnectTimerRef.current = setTimeout(() => {\n          if (wsStateRef.current === WS_STATES.DISCONNECTED && taskIdRef.current) {\n            console.log(`Attempting to reconnect to WebSocket for task: ${taskIdRef.current}`);\n            initializeWebSocket(taskIdRef.current);\n          }\n        }, 5000);\n      }\n    };\n    \n    ws.onerror = (error) => {\n      console.error(`WebSocket error for task ${taskId}:`, error);\n      if (wsStateRef.current !== WS_STATES.DISCONNECTED) {\n        updateWsState(WS_STATES.DISCONNECTED);\n        \n        // Try to reconnect after a delay\n        reconnectTimerRef.current = setTimeout(() => {\n          if (wsStateRef.current === WS_STATES.DISCONNECTED && taskIdRef.current) {\n            console.log(`Attempting to reconnect after error for task: ${taskIdRef.current}`);\n            initializeWebSocket(taskIdRef.current);\n          }\n        }, 5000);\n      }\n    };\n    \n    ws.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        console.log(`WebSocket message received for task ${taskId}:`, data);\n        \n        // Call the provided message handler for all messages\n        if (onMessageRef.current) {\n          onMessageRef.current(data);\n        }\n      } catch (err) {\n        console.error('Error processing WebSocket message:', err);\n      }\n    };\n  }, [updateWsState]);\n\n  // Initialize WebSocket connection with retry logic\n  const initializeWebSocket = useCallback((taskId) => {\n    try {\n      // Only start if we're disconnected\n      if (wsStateRef.current !== WS_STATES.DISCONNECTED) {\n        return;\n      }\n\n      // Rate limiting: prevent too many rapid connection attempts\n      const now = Date.now();\n      if (now - lastConnectionAttemptRef.current < 1000) {\n        console.log('Rate limiting: Too many connection attempts, waiting...');\n        return;\n      }\n      lastConnectionAttemptRef.current = now;\n\n      updateWsState(WS_STATES.CONNECTING);\n      \n      // Get the WebSocket URL\n      let wsUrl;\n      if (typeof urlOrGetter === 'function') {\n        wsUrl = urlOrGetter(taskId);\n      } else {\n        // For backward compatibility\n        wsUrl = taskId ? `${urlOrGetter}/${taskId}` : urlOrGetter;\n      }\n      \n      if (!wsUrl) {\n        console.warn('No WebSocket URL available');\n        updateWsState(WS_STATES.DISCONNECTED);\n        return;\n      }\n      \n      console.log(`Connecting to WebSocket URL: ${wsUrl}`);\n      // Store the task ID for reconnection\n      taskIdRef.current = taskId;\n      const ws = new WebSocket(wsUrl);\n      socketRef.current = ws;\n\n      // Set up all event handlers\n      setupWebSocketHandlers(ws, taskId);\n    } catch (error) {\n      console.error('WebSocket connection error:', error);\n      updateWsState(WS_STATES.DISCONNECTED);\n      \n      // Try to reconnect after a delay\n      reconnectTimerRef.current = setTimeout(() => {\n        if (wsStateRef.current === WS_STATES.DISCONNECTED && taskIdRef.current) {\n          initializeWebSocket(taskIdRef.current);\n        }\n      }, 5000);\n    }\n  }, [urlOrGetter, updateWsState, setupWebSocketHandlers]);\n\n  // Connect to WebSocket\n  const connect = useCallback((taskId) => {\n    // Don't attempt to connect if taskId is null, undefined, or not a valid UUID\n    if (!taskId || !/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(taskId)) {\n      console.warn('Not connecting WebSocket: Invalid or missing task ID');\n      disconnect();\n      return;\n    }\n    \n    // If already connected to this task, do nothing\n    if (socketRef.current && \n        wsStateRef.current === WS_STATES.CONNECTED && \n        taskIdRef.current === taskId) {\n      console.log(`Already connected to task ${taskId}, skipping connection`);\n      return;\n    }\n    \n    // If we're already trying to connect to this task, wait\n    if (wsStateRef.current === WS_STATES.CONNECTING && taskIdRef.current === taskId) {\n      console.log(`Already connecting to task ${taskId}, waiting...`);\n      return;\n    }\n    \n    // Store the task ID\n    taskIdRef.current = taskId;\n    \n    // Clean up any existing connection and wait for it to close\n    if (socketRef.current) {\n      console.log(`Switching from ${taskIdRef.current} to ${taskId}, cleaning up old connection`);\n      disconnect();\n      \n      // Wait a bit before creating new connection to ensure cleanup is complete\n      setTimeout(() => {\n        if (taskIdRef.current === taskId) {\n          initializeWebSocket(taskId);\n        }\n      }, 100);\n    } else {\n      // No existing connection, initialize immediately\n      initializeWebSocket(taskId);\n    }\n  }, [disconnect, initializeWebSocket]);\n  \n  // Clean up on unmount\n  useEffect(() => {\n    return () => {\n      disconnect();\n    };\n  }, [disconnect]);\n\n  return {\n    wsState,\n    connect,\n    disconnect,\n    isConnected: wsState === WS_STATES.CONNECTED,\n    currentTaskId: taskIdRef.current\n  };\n};\n\nexport default useWebSocket;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}