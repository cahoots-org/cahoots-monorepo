{"ast":null,"code":"var _window$CAHOOTS_CONFI;import React,{createContext,useState,useEffect,useRef,useCallback}from'react';import useWebSocket from'../hooks/useWebSocket';import apiClient from'../services/unifiedApiClient';// Get API URL from runtime config (same as unifiedApiClient)\nimport{jsx as _jsx}from\"react/jsx-runtime\";const API_URL=((_window$CAHOOTS_CONFI=window.CAHOOTS_CONFIG)===null||_window$CAHOOTS_CONFI===void 0?void 0:_window$CAHOOTS_CONFI.API_URL)||'/api';// Function to get WebSocket URL for a specific task\nconst getWebSocketUrl=taskId=>{if(!taskId){console.error('No task ID provided for WebSocket connection');return null;}// Use the same logic as other WebSocket connections\nconst protocol=window.location.protocol==='https:'?'wss:':'ws:';const host=window.location.hostname;// In production (HTTPS), don't include port\nif(window.location.protocol==='https:'){return`${protocol}//${host}/ws/tasks/${taskId}`;}// In development, use port 8080\nconst port=process.env.REACT_APP_API_URL?new URL(process.env.REACT_APP_API_URL).port||'8080':'8080';return`${protocol}//${host}:${port}/ws/tasks/${taskId}`;};export const TaskContext=/*#__PURE__*/createContext();export const TaskProvider=_ref=>{let{children}=_ref;// Core state\nconst[tasks,setTasks]=useState([]);const[loading,setLoading]=useState(false);const[error,setError]=useState(null);const[currentTask,setCurrentTask]=useState({});const[taskTree,setTaskTree]=useState({});const[currentTaskId,setCurrentTaskId]=useState(null);const[operatorStatus,setOperatorStatus]=useState({});// Create refs for functions that will be used in the WebSocket callback\nconst getTaskRef=useRef(null);const updateTaskStatusRef=useRef(null);const fetchTasksRef=useRef(null);const fetchTaskTreeRef=useRef(null);// Function to fetch a specific task\nconst getTask=useCallback(async taskId=>{if(!taskId)return null;try{setLoading(true);setError(null);const response=await apiClient.get(`/tasks/${taskId}`);return response;}catch(err){console.error(`Error fetching task ${taskId}:`,err);setError(`Failed to fetch task: ${err.message}`);return null;}finally{setLoading(false);}},[]);// Store getTask in ref\nuseEffect(()=>{getTaskRef.current=getTask;},[getTask]);// Function to fetch the task tree for a specific task\nconst fetchTaskTree=useCallback(async taskId=>{if(!taskId){// fetchTaskTree called without taskId\nreturn;}try{setLoading(true);setError(null);const treeData=await apiClient.get(`/tasks/${taskId}/tree`);if(!treeData){console.error('Received null or undefined tree data for taskId:',taskId);setError('Failed to load task tree: No data received');setLoading(false);return null;}console.log('Successfully fetched task tree:',treeData);// Create a completely new object reference to ensure React detects the change\nsetTaskTree(prev=>{const newState={...prev};// Create a deep copy of the tree data to ensure React detects the change\nnewState[taskId]=JSON.parse(JSON.stringify(treeData));console.log('Updated task tree state with new reference:',taskId,newState[taskId]);return newState;});setLoading(false);return treeData;}catch(err){console.error('Error fetching task tree:',err);setLoading(false);setError(`Failed to load task tree: ${err.message}`);throw err;}},[]);// Store fetchTaskTree in ref\nuseEffect(()=>{fetchTaskTreeRef.current=fetchTaskTree;},[fetchTaskTree]);// Function to fetch all tasks\nconst fetchTasks=useCallback(async function(){let topLevelOnly=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;console.log('fetchTasks called with topLevelOnly:',topLevelOnly);try{setLoading(true);setError(null);const params=new URLSearchParams();if(topLevelOnly){params.append('top_level_only','true');}const response=await apiClient.get(`/tasks?${params.toString()}`);const tasksData=Array.isArray(response)?response:response.tasks||[];setTasks(tasksData);setLoading(false);return tasksData;}catch(err){console.error('Error fetching tasks:',err);setLoading(false);setError(`Failed to load tasks: ${err.message}`);throw err;}},[]);// Store fetchTasks in ref\nuseEffect(()=>{fetchTasksRef.current=fetchTasks;},[fetchTasks]);// Update task status\nconst updateTaskStatus=useCallback(async(taskId,status)=>{try{setLoading(true);setError(null);await apiClient.patch(`/tasks/${taskId}`,{status});// Refresh task list after updating task status\nif(fetchTasksRef.current){await fetchTasksRef.current();}setLoading(false);return true;}catch(err){console.error('Error updating task status:',err);setLoading(false);setError(`Failed to update task status: ${err.message}`);throw err;}},[]);// Store updateTaskStatus in ref\nuseEffect(()=>{updateTaskStatusRef.current=updateTaskStatus;},[updateTaskStatus]);// Function to directly refresh a task tree (for future use)\n// eslint-disable-next-line no-unused-vars\nconst _refreshTaskTree=useCallback(async taskId=>{try{if(!fetchTaskTreeRef.current)return;console.log(`Directly refreshing task tree for ${taskId}`);const updatedTree=await fetchTaskTreeRef.current(taskId);if(updatedTree){console.log(`Got updated task tree for ${taskId}:`,updatedTree);// Force a re-render by creating a completely new object reference\nsetTaskTree(prevTrees=>{const newTrees=JSON.parse(JSON.stringify(prevTrees));// Deep clone\nnewTrees[taskId]=updatedTree;console.log(`Updated task tree state for ${taskId}`);return newTrees;});}}catch(err){console.error(`Error refreshing task tree for ${taskId}:`,err);}},[]);// Initialize WebSocket hook with message handler\nconst onMessageCallback=useCallback(data=>{try{console.log('WebSocket message received:',data);// Handle connection test messages\nif(data.type==='connection_test'||data.type==='connection_established'){return;}// Handle event history\nif(data.type==='event_history'&&Array.isArray(data.events)){console.log(`Received event history with ${data.events.length} events for task ${data.task_id}`);// Process each event in the history\ndata.events.forEach(event=>{console.log(`Processing historical event: ${event.channel}`,event.data);// Create a synthetic message from the historical event\nconst eventData={...event.data,type:event.channel,// Use the channel as the message type\ntimestamp:event.timestamp};// Process the event by calling this same callback recursively\n// but skip event_history to prevent infinite recursion\nif(eventData.type!=='event_history'){onMessageCallback(eventData);}});}// Handle operator status updates\nelse if(data.type==='operator.status'){console.log(`Operator status update for task ${data.task_id}:`,data);// Update operator status in state\nsetOperatorStatus(prev=>({...prev,[data.operator_id]:{status:data.status,message:data.message,timestamp:data.timestamp,task_id:data.task_id}}));// If this is a completion message, check if the task is atomic\nif(data.status==='completed'&&data.task_id){if(apiClient){console.log(`Checking if task ${data.task_id} is atomic after operator completion`);apiClient.get(`/tasks/${data.task_id}`).then(response=>{const task=response.data;// If task is atomic and not completed, auto-complete it\nif(task&&task.is_atomic&&task.status!=='completed'){console.log(`Auto-completing atomic task ${data.task_id}`);apiClient.patch(`/tasks/${data.task_id}`,{status:'completed',is_atomic:true// Ensure is_atomic is set\n}).then(()=>{console.log(`Task ${data.task_id} marked as completed`);// Force refresh the task tree to reflect changes\nif(getTaskRef.current){setTimeout(()=>getTaskRef.current(data.task_id),200);}}).catch(err=>console.error('Error auto-completing atomic task:',err));}}).catch(err=>{console.error('Error checking if task is atomic:',err);});}}}// Handle task update messages\nelse if(data.type&&data.type.startsWith('task.')){console.log(`Received ${data.type} event for task ${data.task_id}`,data);// Update current task if it matches\nif(currentTask&&currentTask.id===data.task_id){console.log(`Updating current task ${data.task_id} with new data`);setCurrentTask(prev=>{const updatedTask={...prev,status:data.status||prev.status,is_atomic:data.is_atomic!==undefined?data.is_atomic:prev.is_atomic};// If task is marked as completed, update UI immediately\nif(data.status==='completed'&&prev.status!=='completed'){console.log(`Task ${data.task_id} marked as completed`);}// If task is marked as atomic, update UI immediately\nif(data.is_atomic&&!prev.is_atomic){console.log(`Task ${data.task_id} marked as atomic`);}return updatedTask;});}// Function to refresh task tree and its ancestors\nconst refreshTaskAndAncestors=async taskId=>{try{if(!getTaskRef.current)return;console.log(`Refreshing task tree for ${taskId}`);// First refresh this task's tree\nconst updatedTask=await getTaskRef.current(taskId);// Update tasks in state if this task is loaded\nif(updatedTask){setTasks(prevTasks=>{// Find and update the task in the tasks array\nreturn prevTasks.map(task=>{if(task.id===taskId){return{...task,status:updatedTask.status,is_atomic:updatedTask.is_atomic,predictions:updatedTask.predictions||task.predictions};}return task;});});}// Then refresh all ancestor tasks\nif(updatedTask&&updatedTask.parent_id){await refreshTaskAndAncestors(updatedTask.parent_id);}}catch(err){console.error(`Error refreshing task ${taskId} and ancestors:`,err);}};// Always refresh task data regardless of whether it's the current task\n// This ensures we update the task list even if the user isn't viewing the task\nif(data.task_id){console.log(`Refreshing task data for ${data.task_id} due to ${data.type} event`);// Use a small delay to ensure the backend has processed the update\nsetTimeout(()=>refreshTaskAndAncestors(data.task_id),100);}// Refresh the main tasks list for any task event\nif(fetchTasksRef.current){fetchTasksRef.current().catch(err=>{console.error('Error refreshing tasks list after event:',err);});}}}catch(err){console.error('Error handling WebSocket message:',err);}},[]);// Initialize WebSocket hook with a function to get the URL\nconst{wsState,connect,disconnect}=useWebSocket(taskId=>getWebSocketUrl(taskId),onMessageCallback);// Debug WebSocket state changes\nuseEffect(()=>{console.log('WebSocket state changed:',wsState);},[wsState]);// Connect to WebSocket ONLY when currentTaskId changes AND is valid\nuseEffect(()=>{// Only connect if we have a valid task ID (UUID format)\nconst isValidTaskId=currentTaskId&&/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(currentTaskId);if(isValidTaskId){console.log('Connecting to WebSocket for task:',currentTaskId);connect(currentTaskId);}else{console.log('Not connecting WebSocket: No valid task ID');disconnect();}// Cleanup on unmount or when currentTaskId changes\nreturn()=>{console.log('Cleaning up WebSocket connection');disconnect();};},[currentTaskId]);// Remove connect/disconnect from dependencies to prevent render loop\n// Initial data fetch\nuseEffect(()=>{// Check if user is authenticated before fetching tasks\nconst token=localStorage.getItem('token');if(token){console.log('TaskContext: User authenticated, fetching initial tasks');fetchTasks().catch(err=>{console.error('Error in initial tasks fetch:',err);});}else{console.log('TaskContext: No authentication token found, skipping initial task fetch');}},[]);// Remove fetchTasks from dependencies to prevent render loop\n// Create a task\nconst createTask=useCallback(async taskData=>{try{setLoading(true);setError(null);const newTask=await apiClient.post('/tasks',taskData);console.log('Task created successfully:',newTask);// Refresh task list after creating a new task\nfetchTasks();// Immediately fetch the task tree for the new task\nif(newTask&&newTask.task_id){try{console.log('Pre-fetching task tree for newly created task:',newTask.task_id);await fetchTaskTree(newTask.task_id);}catch(treeErr){console.error('Failed to pre-fetch task tree, but continuing:',treeErr);// Don't rethrow - we still want to return the created task\n}}setLoading(false);return newTask;}catch(err){console.error('Error creating task:',err);setLoading(false);setError(`Failed to create task: ${err.message}`);throw err;}},[fetchTasks,fetchTaskTree]);// Delete a task\nconst deleteTask=useCallback(async taskId=>{try{setLoading(true);setError(null);await apiClient.delete(`/tasks/${taskId}`);// Refresh task list after deleting a task\nawait fetchTasks();setLoading(false);return true;}catch(err){console.error('Error deleting task:',err);setLoading(false);setError(`Failed to delete task: ${err.message}`);throw err;}},[fetchTasks]);return/*#__PURE__*/_jsx(TaskContext.Provider,{value:{tasks,loading,error,currentTask,taskTree,operatorStatus,currentTaskId,fetchTasks,getTask,fetchTaskTree,createTask,deleteTask,updateTaskStatus,connectWebSocket:connect,disconnectWebSocket:disconnect,wsState,setError,setCurrentTaskId},children:children});};","map":{"version":3,"names":["React","createContext","useState","useEffect","useRef","useCallback","useWebSocket","apiClient","jsx","_jsx","API_URL","_window$CAHOOTS_CONFI","window","CAHOOTS_CONFIG","getWebSocketUrl","taskId","console","error","protocol","location","host","hostname","port","process","env","REACT_APP_API_URL","URL","TaskContext","TaskProvider","_ref","children","tasks","setTasks","loading","setLoading","setError","currentTask","setCurrentTask","taskTree","setTaskTree","currentTaskId","setCurrentTaskId","operatorStatus","setOperatorStatus","getTaskRef","updateTaskStatusRef","fetchTasksRef","fetchTaskTreeRef","getTask","response","get","err","message","current","fetchTaskTree","treeData","log","prev","newState","JSON","parse","stringify","fetchTasks","topLevelOnly","arguments","length","undefined","params","URLSearchParams","append","toString","tasksData","Array","isArray","updateTaskStatus","status","patch","_refreshTaskTree","updatedTree","prevTrees","newTrees","onMessageCallback","data","type","events","task_id","forEach","event","channel","eventData","timestamp","operator_id","then","task","is_atomic","setTimeout","catch","startsWith","id","updatedTask","refreshTaskAndAncestors","prevTasks","map","predictions","parent_id","wsState","connect","disconnect","isValidTaskId","test","token","localStorage","getItem","createTask","taskData","newTask","post","treeErr","deleteTask","delete","Provider","value","connectWebSocket","disconnectWebSocket"],"sources":["/app/src/contexts/TaskContext.js"],"sourcesContent":["import React, { createContext, useState, useEffect, useRef, useCallback } from 'react';\nimport useWebSocket from '../hooks/useWebSocket';\nimport apiClient from '../services/unifiedApiClient';\n\n// Get API URL from runtime config (same as unifiedApiClient)\nconst API_URL = window.CAHOOTS_CONFIG?.API_URL || '/api';\n\n// Function to get WebSocket URL for a specific task\nconst getWebSocketUrl = (taskId) => {\n  if (!taskId) {\n    console.error('No task ID provided for WebSocket connection');\n    return null;\n  }\n  \n  // Use the same logic as other WebSocket connections\n  const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n  const host = window.location.hostname;\n  \n  // In production (HTTPS), don't include port\n  if (window.location.protocol === 'https:') {\n    return `${protocol}//${host}/ws/tasks/${taskId}`;\n  }\n  \n  // In development, use port 8080\n  const port = process.env.REACT_APP_API_URL ? \n    new URL(process.env.REACT_APP_API_URL).port || '8080' : \n    '8080';\n  return `${protocol}//${host}:${port}/ws/tasks/${taskId}`;\n};\n\n\nexport const TaskContext = createContext();\n\nexport const TaskProvider = ({ children }) => {\n  // Core state\n  const [tasks, setTasks] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [currentTask, setCurrentTask] = useState({});\n  const [taskTree, setTaskTree] = useState({});\n  const [currentTaskId, setCurrentTaskId] = useState(null);\n  const [operatorStatus, setOperatorStatus] = useState({});\n\n  // Create refs for functions that will be used in the WebSocket callback\n  const getTaskRef = useRef(null);\n  const updateTaskStatusRef = useRef(null);\n  const fetchTasksRef = useRef(null);\n  const fetchTaskTreeRef = useRef(null);\n\n  // Function to fetch a specific task\n  const getTask = useCallback(async (taskId) => {\n    if (!taskId) return null;\n    \n    try {\n      setLoading(true);\n      setError(null);\n      \n      const response = await apiClient.get(`/tasks/${taskId}`);\n      return response;\n    } catch (err) {\n      console.error(`Error fetching task ${taskId}:`, err);\n      setError(`Failed to fetch task: ${err.message}`);\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Store getTask in ref\n  useEffect(() => {\n    getTaskRef.current = getTask;\n  }, [getTask]);\n\n  // Function to fetch the task tree for a specific task\n  const fetchTaskTree = useCallback(async (taskId) => {\n    if (!taskId) {\n      // fetchTaskTree called without taskId\n      return;\n    }\n    \n    \n    try {\n      setLoading(true);\n      setError(null);\n      \n      const treeData = await apiClient.get(`/tasks/${taskId}/tree`);\n      \n      if (!treeData) {\n        console.error('Received null or undefined tree data for taskId:', taskId);\n        setError('Failed to load task tree: No data received');\n        setLoading(false);\n        return null;\n      }\n      \n      console.log('Successfully fetched task tree:', treeData);\n      \n      // Create a completely new object reference to ensure React detects the change\n      setTaskTree((prev) => {\n        const newState = { ...prev };\n        // Create a deep copy of the tree data to ensure React detects the change\n        newState[taskId] = JSON.parse(JSON.stringify(treeData));\n        console.log('Updated task tree state with new reference:', taskId, newState[taskId]);\n        return newState;\n      });\n      \n      setLoading(false);\n      return treeData;\n    } catch (err) {\n      console.error('Error fetching task tree:', err);\n      setLoading(false);\n      setError(`Failed to load task tree: ${err.message}`);\n      throw err;\n    }\n  }, []);\n\n  // Store fetchTaskTree in ref\n  useEffect(() => {\n    fetchTaskTreeRef.current = fetchTaskTree;\n  }, [fetchTaskTree]);\n\n  // Function to fetch all tasks\n  const fetchTasks = useCallback(async (topLevelOnly = true) => {\n    console.log('fetchTasks called with topLevelOnly:', topLevelOnly);\n    \n    try {\n      setLoading(true);\n      setError(null);\n      \n      const params = new URLSearchParams();\n      if (topLevelOnly) {\n        params.append('top_level_only', 'true');\n      }\n      \n      const response = await apiClient.get(`/tasks?${params.toString()}`);\n      const tasksData = Array.isArray(response) ? response : response.tasks || [];\n      \n      setTasks(tasksData);\n      setLoading(false);\n      return tasksData;\n    } catch (err) {\n      console.error('Error fetching tasks:', err);\n      setLoading(false);\n      setError(`Failed to load tasks: ${err.message}`);\n      throw err;\n    }\n  }, []);\n\n  // Store fetchTasks in ref\n  useEffect(() => {\n    fetchTasksRef.current = fetchTasks;\n  }, [fetchTasks]);\n\n  // Update task status\n  const updateTaskStatus = useCallback(async (taskId, status) => {\n    try {\n      setLoading(true);\n      setError(null);\n      \n      await apiClient.patch(`/tasks/${taskId}`, { status });\n      \n      // Refresh task list after updating task status\n      if (fetchTasksRef.current) {\n        await fetchTasksRef.current();\n      }\n      \n      setLoading(false);\n      return true;\n    } catch (err) {\n      console.error('Error updating task status:', err);\n      setLoading(false);\n      setError(`Failed to update task status: ${err.message}`);\n      throw err;\n    }\n  }, []);\n\n  // Store updateTaskStatus in ref\n  useEffect(() => {\n    updateTaskStatusRef.current = updateTaskStatus;\n  }, [updateTaskStatus]);\n\n  // Function to directly refresh a task tree (for future use)\n  // eslint-disable-next-line no-unused-vars\n  const _refreshTaskTree = useCallback(async (taskId) => {\n    try {\n      if (!fetchTaskTreeRef.current) return;\n      \n      console.log(`Directly refreshing task tree for ${taskId}`);\n      const updatedTree = await fetchTaskTreeRef.current(taskId);\n      \n      if (updatedTree) {\n        console.log(`Got updated task tree for ${taskId}:`, updatedTree);\n        \n        // Force a re-render by creating a completely new object reference\n        setTaskTree(prevTrees => {\n          const newTrees = JSON.parse(JSON.stringify(prevTrees)); // Deep clone\n          newTrees[taskId] = updatedTree;\n          console.log(`Updated task tree state for ${taskId}`);\n          return newTrees;\n        });\n      }\n    } catch (err) {\n      console.error(`Error refreshing task tree for ${taskId}:`, err);\n    }\n  }, []);\n  \n  // Initialize WebSocket hook with message handler\n  const onMessageCallback = useCallback((data) => {\n      try {\n        console.log('WebSocket message received:', data);\n        \n        // Handle connection test messages\n        if (data.type === 'connection_test' || data.type === 'connection_established') {\n          return;\n        }\n        \n        // Handle event history\n        if (data.type === 'event_history' && Array.isArray(data.events)) {\n          console.log(`Received event history with ${data.events.length} events for task ${data.task_id}`);\n          \n          // Process each event in the history\n          data.events.forEach(event => {\n            console.log(`Processing historical event: ${event.channel}`, event.data);\n            \n            // Create a synthetic message from the historical event\n            const eventData = {\n              ...event.data,\n              type: event.channel,  // Use the channel as the message type\n              timestamp: event.timestamp\n            };\n            \n            // Process the event by calling this same callback recursively\n            // but skip event_history to prevent infinite recursion\n            if (eventData.type !== 'event_history') {\n              onMessageCallback(eventData);\n            }\n          });\n        }\n        \n        // Handle operator status updates\n        else if (data.type === 'operator.status') {\n          console.log(`Operator status update for task ${data.task_id}:`, data);\n          \n          // Update operator status in state\n          setOperatorStatus(prev => ({\n            ...prev,\n            [data.operator_id]: {\n              status: data.status,\n              message: data.message,\n              timestamp: data.timestamp,\n              task_id: data.task_id\n            }\n          }));\n          \n          // If this is a completion message, check if the task is atomic\n          if (data.status === 'completed' && data.task_id) {\n            if (apiClient) {\n              console.log(`Checking if task ${data.task_id} is atomic after operator completion`);\n              apiClient.get(`/tasks/${data.task_id}`)\n              .then(response => {\n                const task = response.data;\n                // If task is atomic and not completed, auto-complete it\n                if (task && task.is_atomic && task.status !== 'completed') {\n                  console.log(`Auto-completing atomic task ${data.task_id}`);\n                  apiClient.patch(`/tasks/${data.task_id}`, { \n                    status: 'completed',\n                    is_atomic: true // Ensure is_atomic is set\n                  })\n                    .then(() => {\n                      console.log(`Task ${data.task_id} marked as completed`);\n                      // Force refresh the task tree to reflect changes\n                      if (getTaskRef.current) {\n                        setTimeout(() => getTaskRef.current(data.task_id), 200);\n                      }\n                    })\n                    .catch(err => console.error('Error auto-completing atomic task:', err));\n                }\n              }).catch(err => {\n                console.error('Error checking if task is atomic:', err);\n              });\n            }\n          }\n        }\n        // Handle task update messages\n        else if (data.type && data.type.startsWith('task.')) {\n          console.log(`Received ${data.type} event for task ${data.task_id}`, data);\n          \n          // Update current task if it matches\n          if (currentTask && currentTask.id === data.task_id) {\n            console.log(`Updating current task ${data.task_id} with new data`);\n            setCurrentTask(prev => {\n              const updatedTask = {\n                ...prev,\n                status: data.status || prev.status,\n                is_atomic: data.is_atomic !== undefined ? data.is_atomic : prev.is_atomic\n              };\n              \n              // If task is marked as completed, update UI immediately\n              if (data.status === 'completed' && prev.status !== 'completed') {\n                console.log(`Task ${data.task_id} marked as completed`);\n              }\n              \n              // If task is marked as atomic, update UI immediately\n              if (data.is_atomic && !prev.is_atomic) {\n                console.log(`Task ${data.task_id} marked as atomic`);\n              }\n              \n              return updatedTask;\n            });\n          }\n          \n          // Function to refresh task tree and its ancestors\n          const refreshTaskAndAncestors = async (taskId) => {\n            try {\n              if (!getTaskRef.current) return;\n              \n              console.log(`Refreshing task tree for ${taskId}`);\n              // First refresh this task's tree\n              const updatedTask = await getTaskRef.current(taskId);\n              \n              // Update tasks in state if this task is loaded\n              if (updatedTask) {\n                setTasks(prevTasks => {\n                  // Find and update the task in the tasks array\n                  return prevTasks.map(task => {\n                    if (task.id === taskId) {\n                      return {\n                        ...task,\n                        status: updatedTask.status,\n                        is_atomic: updatedTask.is_atomic,\n                        predictions: updatedTask.predictions || task.predictions\n                      };\n                    }\n                    return task;\n                  });\n                });\n              }\n              \n              // Then refresh all ancestor tasks\n              if (updatedTask && updatedTask.parent_id) {\n                await refreshTaskAndAncestors(updatedTask.parent_id);\n              }\n            } catch (err) {\n              console.error(`Error refreshing task ${taskId} and ancestors:`, err);\n            }\n          };\n          \n          // Always refresh task data regardless of whether it's the current task\n          // This ensures we update the task list even if the user isn't viewing the task\n          if (data.task_id) {\n            console.log(`Refreshing task data for ${data.task_id} due to ${data.type} event`);\n            // Use a small delay to ensure the backend has processed the update\n            setTimeout(() => refreshTaskAndAncestors(data.task_id), 100);\n          }\n          \n          // Refresh the main tasks list for any task event\n          if (fetchTasksRef.current) {\n            fetchTasksRef.current().catch(err => {\n              console.error('Error refreshing tasks list after event:', err);\n            });\n          }\n        }\n      } catch (err) {\n        console.error('Error handling WebSocket message:', err);\n      }\n  }, []);\n\n  // Initialize WebSocket hook with a function to get the URL\n  const { wsState, connect, disconnect } = useWebSocket(\n    (taskId) => getWebSocketUrl(taskId), \n    onMessageCallback\n  );\n\n  // Debug WebSocket state changes\n  useEffect(() => {\n    console.log('WebSocket state changed:', wsState);\n  }, [wsState]);\n\n  // Connect to WebSocket ONLY when currentTaskId changes AND is valid\n  useEffect(() => {\n    // Only connect if we have a valid task ID (UUID format)\n    const isValidTaskId = currentTaskId && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(currentTaskId);\n    \n    if (isValidTaskId) {\n      console.log('Connecting to WebSocket for task:', currentTaskId);\n      connect(currentTaskId);\n    } else {\n      console.log('Not connecting WebSocket: No valid task ID');\n      disconnect();\n    }\n    \n    // Cleanup on unmount or when currentTaskId changes\n    return () => {\n      console.log('Cleaning up WebSocket connection');\n      disconnect();\n    };\n  }, [currentTaskId]); // Remove connect/disconnect from dependencies to prevent render loop\n\n  // Initial data fetch\n  useEffect(() => {\n    // Check if user is authenticated before fetching tasks\n    const token = localStorage.getItem('token');\n    if (token) {\n      console.log('TaskContext: User authenticated, fetching initial tasks');\n      fetchTasks().catch(err => {\n        console.error('Error in initial tasks fetch:', err);\n      });\n    } else {\n      console.log('TaskContext: No authentication token found, skipping initial task fetch');\n    }\n  }, []); // Remove fetchTasks from dependencies to prevent render loop\n\n  // Create a task\n  const createTask = useCallback(async (taskData) => {\n    try {\n      setLoading(true);\n      setError(null);\n      \n      const newTask = await apiClient.post('/tasks', taskData);\n      console.log('Task created successfully:', newTask);\n      \n      // Refresh task list after creating a new task\n      fetchTasks();\n      \n      // Immediately fetch the task tree for the new task\n      if (newTask && newTask.task_id) {\n        try {\n          console.log('Pre-fetching task tree for newly created task:', newTask.task_id);\n          await fetchTaskTree(newTask.task_id);\n        } catch (treeErr) {\n          console.error('Failed to pre-fetch task tree, but continuing:', treeErr);\n          // Don't rethrow - we still want to return the created task\n        }\n      }\n      \n      setLoading(false);\n      return newTask;\n    } catch (err) {\n      console.error('Error creating task:', err);\n      setLoading(false);\n      setError(`Failed to create task: ${err.message}`);\n      throw err;\n    }\n  }, [fetchTasks, fetchTaskTree]);\n\n  // Delete a task\n  const deleteTask = useCallback(async (taskId) => {\n    try {\n      setLoading(true);\n      setError(null);\n      \n      await apiClient.delete(`/tasks/${taskId}`);\n      \n      // Refresh task list after deleting a task\n      await fetchTasks();\n      \n      setLoading(false);\n      return true;\n    } catch (err) {\n      console.error('Error deleting task:', err);\n      setLoading(false);\n      setError(`Failed to delete task: ${err.message}`);\n      throw err;\n    }\n  }, [fetchTasks]);\n\n  return (\n    <TaskContext.Provider\n      value={{\n        tasks,\n        loading,\n        error,\n        currentTask,\n        taskTree,\n        operatorStatus,\n        currentTaskId,\n        fetchTasks,\n        getTask,\n        fetchTaskTree,\n        createTask,\n        deleteTask,\n        updateTaskStatus,\n        connectWebSocket: connect,\n        disconnectWebSocket: disconnect,\n        wsState,\n        setError,\n        setCurrentTaskId,\n      }}\n    >\n      {children}\n    </TaskContext.Provider>\n  );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}